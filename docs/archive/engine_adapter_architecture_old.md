# Engine Adapter Architecture

This document outlines the architecture for interfacing with various game engines (Unity, Godot, Bevy, custom engines) from the Flutter application, primarily facilitated by the **Rust-based `aurax_middleware`**.

## Core Principles

- **Unified Rust Trait:** A single `EngineAdapter` Rust trait, located in `aurax_middleware/src/engine_adapter_trait.rs`, defines the common set of operations that can be performed on any supported game engine.
- **Rust-Based Engine-Specific Adapters:** For each supported game engine, a corresponding Rust struct implements the `EngineAdapter` trait within `aurax_middleware` (e.g., `aurax_middleware/src/unity_adapter.rs`, `aurax_middleware/src/godot_adapter.rs`, `aurax_middleware/src/bevy_adapter.rs`). These adapters are responsible for translating the unified API calls into engine-specific commands.
- **FFI Bridge to Flutter:** Flutter interacts with the Rust middleware via an FFI (Foreign Function Interface) layer generated by `flutter_rust_bridge`. The API exposed to Flutter is defined in `aurax_middleware/src/ffi_editor_api.rs`.
- **Communication Protocols:** Rust adapters use various communication protocols (HTTP, WebSockets, C FFI, direct Rust FFI) to interact with their respective engines.
- **Modularity:** This architecture allows for adding support for new engines by implementing the `EngineAdapter` trait in Rust and updating the `EngineManager` within the middleware.

```mermaid
graph TD
    A[Flutter Application] --> B(Rust FFI Layer <br> ffi_editor_api.rs);
    B --> C{EngineManager (Rust) <br> engine_manager.rs};
    C --> D[UnityEngineAdapter (Rust)];
    C --> E[GodotEngineAdapter (Rust)];
    C --> F[BevyEngineAdapter (Rust)];
    C --> G[CustomEngineAdapter (Rust)];
    D --> H[Unity Engine <br> (via HTTP/WebSocket)];
    E --> I[Godot Engine <br> (via C FFI)];
    F --> J[Bevy Engine <br> (via Rust FFI)];
    G --> K[Custom Engine];
```

## Architecture Components

1.  **`EngineAdapter` Trait (Rust):**
    *   Defines the contract for all engine adapters within the Rust middleware.
    *   Specifies methods for common engine operations like initializing/shutting down the engine, loading levels/assets, spawning/destroying entities, setting entity properties, handling events, etc.
    *   Located in `aurax_middleware/src/engine_adapter_trait.rs`.

2.  **`EngineManager` (Rust):**
    *   A Rust struct responsible for managing instances of available Rust-based engine adapters.
    *   Maintained as a global static instance (`GLOBAL_ENGINE_MANAGER`) within `aurax_middleware/src/lib.rs`.
    *   Provides a way to get the appropriate adapter based on an engine ID.
    *   Located in `aurax_middleware/src/engine_manager.rs`.

3.  **Engine-Specific Adapters (Rust):**
    *   Examples: `UnityEngineAdapter`, `GodotEngineAdapter`, `BevyEngineAdapter` located in `aurax_middleware/src/`.
    *   Implement the `EngineAdapter` Rust trait.
    *   Contain the logic to communicate with a specific game engine:
        *   **Unity:** Uses HTTP for commands and WebSockets for receiving real-time events.
        *   **Godot:** Uses C FFI calls to a GDNative/GDExtension library that interacts with the Godot scene tree.
        *   **Bevy:** Uses direct Rust FFI calls as Bevy is also Rust-based.
    *   Handle serialization/deserialization of data between Rust and the engine's format.

4.  **Flutter-Middleware Communication (FFI):**
    *   Managed by `flutter_rust_bridge`.
    *   The API exposed to Flutter is defined in `aurax_middleware/src/ffi_editor_api.rs`.
    *   Dart code in the Flutter application calls these FFI functions to interact with the `EngineManager` and, through it, the specific engine adapters in Rust.
    *   This FFI layer effectively provides the Dart-side interface to the engine functionalities, abstracting away the Rust implementation details.

5.  **Middleware-Engine Communication Layer:**
    *   **HTTP/REST:** Used by `UnityEngineAdapter` for commands.
    *   **WebSockets:** Used by `UnityEngineAdapter` for real-time events.
    *   **C FFI:** Used by `GodotEngineAdapter` to call into a GDNative/GDExtension library in the Godot engine.
    *   **Rust FFI:** Used by `BevyEngineAdapter` for direct calls to the Bevy engine library.

6.  **Game Engines:**
    *   The actual game engines running the simulation and rendering.
    *   Need to expose an API (e.g., HTTP server, WebSocket server, FFI-callable functions) that their respective Rust adapters can consume.

## Data Models and Events

-   **Shared Rust Data Models:** `aurax_middleware/src/engine_common_models.rs` defines common Rust structs (e.g., `EngineTransform`, `EntitySpawnRequest`) used by the adapters and for FFI if necessary.
-   **Standardized Rust Event Enum:** `aurax_middleware/src/engines_api/models.rs` defines the `EngineRealtimeEvent` Rust enum. Engine adapters convert engine-specific events into this standardized format.
-   **FFI Data Transfer:** Data transferred over the FFI layer between Flutter and Rust is typically serialized (e.g., to JSON strings for complex data, or directly for primitives) as defined by `flutter_rust_bridge` and the functions in `ffi_editor_api.rs`. Flutter receives events as a Dart `Stream` of these standardized `EngineRealtimeEvent` objects (or their Dart equivalents generated by FRB).

## Workflow Example: Spawning an Entity (e.g., in Godot)

1.  **Flutter UI Request:** User action triggers a Dart function call, e.g., `api.spawnEntity(engineId: "godot_engine", data: entitySpawnDataJson)`.
2.  **FFI Call to Rust:** The Dart function calls the corresponding FFI function generated by `flutter_rust_bridge`, which is defined in `aurax_middleware/src/ffi_editor_api.rs` (e.g., `spawn_scene_object`).
3.  **Rust `EngineManager` Delegation:** The FFI function in Rust accesses `GLOBAL_ENGINE_MANAGER` to get the `GodotEngineAdapter`.
4.  **`GodotEngineAdapter` Action:**
    *   The `spawn_entity` method in `GodotEngineAdapter` is called with the `entitySpawnDataJson` (which is a `serde_json::Value`).
    *   The adapter deserializes this `Value` into a shared Rust struct like `EntitySpawnRequest` (from `engine_common_models.rs`).
    *   It then constructs the necessary JSON string arguments for the C FFI call to Godot (e.g., `godot_send_command("SpawnEntity", serialized_request_json_string)`).
5.  **Godot Engine Processing:** The Godot C FFI layer calls into GDScript, which spawns the entity and returns a response (e.g., entity ID as a JSON string).
6.  **Response Handling in Rust:**
    *   `GodotEngineAdapter` receives the response string, parses it, and converts it into an `EngineResult<Value>`.
7.  **FFI Response to Flutter:** The result is returned to the Flutter UI via the FFI callback/Future.

## Event Handling Example: Entity Moved (e.g., from Godot)

1.  **Engine Event:** An entity moves within the Godot engine.
2.  **Godot C FFI Notification:** The Godot engine (via GDScript and the C FFI layer) calls a registered Rust callback function, passing event data as a JSON string.
3.  **Rust Callback Processing (`GodotEngineAdapter` context):**
    *   The static Rust callback (associated with `GodotEngineAdapter`) receives the event JSON string.
    *   It parses the JSON and maps it to a standardized `EngineRealtimeEvent::TransformUpdated` Rust enum variant, populating it with data like `object_id` and `EngineTransform`.
4.  **Event Broadcasting in Rust Middleware:** The adapter broadcasts this `EngineRealtimeEvent` using its `tokio::sync::broadcast::Sender`.
5.  **FFI Stream to Flutter:** The FFI stream established by `connect_to_scene_updates` (in `ffi_editor_api.rs`) forwards this event to Flutter.
6.  **Flutter UI Update:** UI components listening to the Dart `Stream<EngineRealtimeEvent>` react to the event and update accordingly.

This architecture centralizes the core adapter logic in Rust (`aurax_middleware`), providing a robust and performant bridge to various game engines, while Flutter interacts with it through a well-defined FFI layer.
