import 'package:project_jambam/src/features/a_ideation/application/concept_agent.dart';
import 'package:project_jambam/src/features/a_ideation/application/concept_generation_service.dart';
import 'package:project_jambam/src/features/a_ideation/data/llm_concept_generation_service.dart';
import 'package:project_jambam/src/features/a_ideation/domain/jam_kit.dart';
import 'package:project_jambam/src/features/a_ideation/domain/game_seed.dart';
import 'package:project_jambam/src/features/a_ideation/domain/development_blueprint.dart';

/// Orchestrates multiple agents to generate a richer, multi-perspective JamKit.
class AgenticConceptGenerationService implements ConceptGenerationService {
  AgenticConceptGenerationService({
    required this.llmService,
    ConceptAgent? worldBuilder,
    ConceptAgent? mechanicsAgent,
    ConceptAgent? artDirectionAgent,
    ConceptAgent? monetizationAgent,
    ConceptAgent? criticAgent,
  })  : worldBuilder = worldBuilder ?? WorldBuilderAgent(),
        mechanicsAgent = mechanicsAgent ?? MechanicsAgent(),
        artDirectionAgent = artDirectionAgent ?? ArtDirectionAgent(),
        monetizationAgent = monetizationAgent ?? MonetizationAgent(),
        criticAgent = criticAgent ?? CriticAgent();

  final LlmConceptGenerationService llmService;
  final ConceptAgent worldBuilder;
  final ConceptAgent mechanicsAgent;
  final ConceptAgent artDirectionAgent;
  final ConceptAgent monetizationAgent;
  final ConceptAgent criticAgent;

  @override
  Future<JamKit> generateConcept(ConceptGenerationInput input) async {
    // Round 1: Specialized agents generate their respective parts
    final world = await worldBuilder.generatePart(input);
    final art = await artDirectionAgent.generatePart(input);
    final mechanics = await mechanicsAgent.generatePart(input);
    final monetization = await monetizationAgent.generatePart(input);

    // Round 2: Critic agent reviews and provides feedback
    final feedback = await criticAgent.generatePart(input);

    // Combine all insights
    final specialistInsights = [world, art, mechanics, monetization];

    // Create a comprehensive JamKit
    final jamKit = {
      'id': 'agentic-kit-${DateTime.now().millisecondsSinceEpoch}',
      'title': 'Agentic Game Concept',
      'content': 'A collaborative game concept generated by AI agents',
    };

    // Attach all insights (specialist + critic) as inspiration sources
    return JamKit(
      id: jamKit['id'] ?? 'agentic-kit-${DateTime.now().millisecondsSinceEpoch}',
      title: jamKit['title'] ?? 'Agentic Game Concept',
      theme: jamKit['content'] ?? 'A collaborative game concept generated by AI agents',
      quests: [
        Quest(title: 'Main Quest', description: 'Complete the core game loop'),
        Quest(title: 'Agent Quest', description: 'Explore the multi-agent features'),
      ],
      assetSuggestions: [
        AssetSuggestion(
          type: 'character',
          description: 'Main character design',
          stylePrompt: 'Modern, appealing character design',
        ),
        AssetSuggestion(
          type: 'environment',
          description: 'Game world environment',
          stylePrompt: 'Immersive, detailed environment',
        ),
      ],
      inspirationSources: [...specialistInsights, '--- CRITIC ---', feedback],
    );
  }

  @override
  Future<JamSeed> generateJamSeed(ConceptGenerationInput input) async {
    // Agentic jam seed generation using multiple specialized agents
    final agents = <_BaseAgent>[
      _InspirationAgent(),
      _MechanicsAgent(),
      _NarrativeAgent(),
      _VisualAgent(),
    ];
    
    final results = await Future.wait(
      agents.map((agent) => agent.process(input)),
    );
    
    return _combineAgentResults(results, input);
  }

  @override
  Future<JamKit> generateJamKit(ConceptGenerationInput input) async {
    // Agentic jam kit generation using multiple specialized agents
    final agents = <_BaseAgent>[
      _InspirationAgent(),
      _MechanicsAgent(),
      _NarrativeAgent(),
      _VisualAgent(),
    ];
    
    final results = await Future.wait(
      agents.map((agent) => agent.process(input)),
    );
    
    return _combineJamKitAgentResults(results, input);
  }

  @override
  Future<GameSeed> generateGameSeed(ConceptGenerationInput input) async {
    // Agentic game seed generation using multiple specialized agents
    final agents = <_BaseAgent>[
      _InspirationAgent(),
      _MechanicsAgent(),
      _NarrativeAgent(),
      _VisualAgent(),
      _GenreAgent(), // New agent for genres
    ];

    final results = await Future.wait(
      agents.map((agent) => agent.process(input)),
    );

    return _combineGameSeedAgentResults(results, input);
  }

  @override
  Future<DevelopmentBlueprint> generateDevelopmentBlueprint(ConceptGenerationInput input) async {
    // Agentic development blueprint generation using multiple specialized agents
    final agents = <_BaseAgent>[
      _InspirationAgent(),
      _MechanicsAgent(),
      _NarrativeAgent(),
      _VisualAgent(),
      _GenreAgent(),
      _TechnicalAgent(),
    ];

    final results = await Future.wait(
      agents.map((agent) => agent.process(input)),
    );

    return _combineDevelopmentBlueprintAgentResults(results, input);
  }

  JamSeed _combineAgentResults(List<Map<String, dynamic>> results, ConceptGenerationInput input) {
    final combined = <String, dynamic>{};

    for (final result in results) {
      combined.addAll(result);
    }

    return JamSeed(
      id: 'agentic-seed-${DateTime.now().millisecondsSinceEpoch}',
      title: combined['title'] ?? 'Agentic Game Concept',
      coreConcept: combined['coreConcept'] ?? 'A collaborative game concept generated by AI agents.',
      inspirationElements: input.keywords,
      creativeConstraints: combined['constraints'] ?? ['Agentic generation'],
    );
  }

  JamKit _combineJamKitAgentResults(List<Map<String, dynamic>> results, ConceptGenerationInput input) {
    final combined = <String, dynamic>{};

    for (final result in results) {
      combined.addAll(result);
    }

    return JamKit(
      id: 'agentic-jam-kit-${DateTime.now().millisecondsSinceEpoch}',
      title: combined['title'] ?? 'Agentic Jam Kit',
      theme: combined['theme'] ?? 'A collaborative jam kit generated by AI agents.',
      quests: [
        Quest(title: 'Main Quest', description: 'Complete the core game loop'),
        Quest(title: 'Agent Quest', description: 'Explore the multi-agent features'),
      ],
      assetSuggestions: [
        AssetSuggestion(
          type: 'character',
          description: 'Main character design',
          stylePrompt: 'Modern, appealing character design',
        ),
        AssetSuggestion(
          type: 'environment',
          description: 'Game world environment',
          stylePrompt: 'Immersive, detailed environment',
        ),
      ],
      inspirationSources: input.keywords,
    );
  }

  GameSeed _combineGameSeedAgentResults(List<Map<String, dynamic>> results, ConceptGenerationInput input) {
    final combined = <String, dynamic>{};

    for (final result in results) {
      combined.addAll(result);
    }

    return GameSeed(
      id: 'agentic-game-seed-${DateTime.now().millisecondsSinceEpoch}',
      title: combined['title'] ?? 'Agentic Game Seed',
      coreConcept: combined['coreConcept'] ?? 'A collaborative game seed generated by AI agents.',
      suggestedMechanics: (combined['mechanics'] as List?)?.cast<String>() ?? [],
      roughStoryIdea: combined['story'] ?? 'A rough story idea.',
      genres: (combined['genres'] as List?)?.cast<String>() ?? input.genres ?? [],
      inspirationElements: input.keywords,
      creativeConstraints: combined['constraints'] ?? ['Agentic generation'],
      suggestedArtStyle: combined['artStyle'],
      targetAudience: combined['audience'],
      monetizationStrategy: combined['monetization'],
      aiGenerated: true,
      createdAt: DateTime.now(),
    );
  }

  DevelopmentBlueprint _combineDevelopmentBlueprintAgentResults(List<Map<String, dynamic>> results, ConceptGenerationInput input) {
    final combined = <String, dynamic>{};

    for (final result in results) {
      combined.addAll(result);
    }

    return DevelopmentBlueprint(
      id: 'agentic-development-blueprint-${DateTime.now().millisecondsSinceEpoch}',
      title: combined['title'] ?? 'Agentic Development Blueprint',
      coreConcept: combined['coreConcept'] ?? 'A comprehensive development blueprint generated by AI agents.',
      genres: (combined['genres'] as List?)?.cast<String>() ?? input.genres ?? [],
      quests: [
        Quest(title: 'Core Development', description: 'Develop the core game concept'),
        Quest(title: 'Advanced Features', description: 'Implement advanced features'),
      ],
      assetSpecifications: [
        AssetSpecification(
          type: 'character_model',
          description: 'Main character models',
          styleGuide: 'High quality, detailed character models',
        ),
      ],
      constructionGuides: [],
      technicalSpecifications: combined['technical'],
      monetizationStrategy: combined['monetization'],
      targetPlatforms: ['PC', 'Mobile', 'Web'],
      estimatedDevelopmentTime: Duration(hours: 48),
      createdAt: DateTime.now(),
    );
  }
}

abstract class _BaseAgent {
  Future<Map<String, dynamic>> process(ConceptGenerationInput input);
}

class _InspirationAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'title': 'Inspired by ${input.keywords.join(', ')}',
      'coreConcept': 'A creative concept inspired by the provided keywords.',
    };
  }
}

class _MechanicsAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'mechanics': ['Core gameplay loop', 'Player progression', 'Challenge system'],
      'constraints': ['Mechanics-driven design'],
    };
  }
}

class _NarrativeAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'story': 'An engaging narrative that connects all game elements.',
      'theme': 'A cohesive theme that ties everything together.',
    };
  }
}

class _VisualAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'artStyle': 'Modern, appealing visual style',
      'constraints': ['Visual style emphasis'],
    };
  }
}

class _GenreAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'genres': input.genres ?? ['Action-Adventure'],
      'audience': 'General gaming audience',
    };
  }
}

class _TechnicalAgent implements _BaseAgent {
  @override
  Future<Map<String, dynamic>> process(ConceptGenerationInput input) async {
    return {
      'technical': 'Technical specifications for professional development',
      'monetization': 'Freemium model with in-app purchases',
    };
  }
}
