// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'multi_agent_system.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

MultiAgentSystem _$MultiAgentSystemFromJson(Map<String, dynamic> json) {
  return _MultiAgentSystem.fromJson(json);
}

/// @nodoc
mixin _$MultiAgentSystem {
  ResearchAgent get researchAgent => throw _privateConstructorUsedError;
  CreativeDirectorAgent get creativeDirectorAgent =>
      throw _privateConstructorUsedError;
  AssetGenerationAgent get assetGenerationAgent =>
      throw _privateConstructorUsedError;
  AgentOrchestrator get orchestrator => throw _privateConstructorUsedError;

  /// Serializes this MultiAgentSystem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MultiAgentSystemCopyWith<MultiAgentSystem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultiAgentSystemCopyWith<$Res> {
  factory $MultiAgentSystemCopyWith(
    MultiAgentSystem value,
    $Res Function(MultiAgentSystem) then,
  ) = _$MultiAgentSystemCopyWithImpl<$Res, MultiAgentSystem>;
  @useResult
  $Res call({
    ResearchAgent researchAgent,
    CreativeDirectorAgent creativeDirectorAgent,
    AssetGenerationAgent assetGenerationAgent,
    AgentOrchestrator orchestrator,
  });

  $ResearchAgentCopyWith<$Res> get researchAgent;
  $CreativeDirectorAgentCopyWith<$Res> get creativeDirectorAgent;
  $AssetGenerationAgentCopyWith<$Res> get assetGenerationAgent;
  $AgentOrchestratorCopyWith<$Res> get orchestrator;
}

/// @nodoc
class _$MultiAgentSystemCopyWithImpl<$Res, $Val extends MultiAgentSystem>
    implements $MultiAgentSystemCopyWith<$Res> {
  _$MultiAgentSystemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? researchAgent = null,
    Object? creativeDirectorAgent = null,
    Object? assetGenerationAgent = null,
    Object? orchestrator = null,
  }) {
    return _then(
      _value.copyWith(
            researchAgent: null == researchAgent
                ? _value.researchAgent
                : researchAgent // ignore: cast_nullable_to_non_nullable
                      as ResearchAgent,
            creativeDirectorAgent: null == creativeDirectorAgent
                ? _value.creativeDirectorAgent
                : creativeDirectorAgent // ignore: cast_nullable_to_non_nullable
                      as CreativeDirectorAgent,
            assetGenerationAgent: null == assetGenerationAgent
                ? _value.assetGenerationAgent
                : assetGenerationAgent // ignore: cast_nullable_to_non_nullable
                      as AssetGenerationAgent,
            orchestrator: null == orchestrator
                ? _value.orchestrator
                : orchestrator // ignore: cast_nullable_to_non_nullable
                      as AgentOrchestrator,
          )
          as $Val,
    );
  }

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResearchAgentCopyWith<$Res> get researchAgent {
    return $ResearchAgentCopyWith<$Res>(_value.researchAgent, (value) {
      return _then(_value.copyWith(researchAgent: value) as $Val);
    });
  }

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreativeDirectorAgentCopyWith<$Res> get creativeDirectorAgent {
    return $CreativeDirectorAgentCopyWith<$Res>(_value.creativeDirectorAgent, (
      value,
    ) {
      return _then(_value.copyWith(creativeDirectorAgent: value) as $Val);
    });
  }

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssetGenerationAgentCopyWith<$Res> get assetGenerationAgent {
    return $AssetGenerationAgentCopyWith<$Res>(_value.assetGenerationAgent, (
      value,
    ) {
      return _then(_value.copyWith(assetGenerationAgent: value) as $Val);
    });
  }

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AgentOrchestratorCopyWith<$Res> get orchestrator {
    return $AgentOrchestratorCopyWith<$Res>(_value.orchestrator, (value) {
      return _then(_value.copyWith(orchestrator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MultiAgentSystemImplCopyWith<$Res>
    implements $MultiAgentSystemCopyWith<$Res> {
  factory _$$MultiAgentSystemImplCopyWith(
    _$MultiAgentSystemImpl value,
    $Res Function(_$MultiAgentSystemImpl) then,
  ) = __$$MultiAgentSystemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    ResearchAgent researchAgent,
    CreativeDirectorAgent creativeDirectorAgent,
    AssetGenerationAgent assetGenerationAgent,
    AgentOrchestrator orchestrator,
  });

  @override
  $ResearchAgentCopyWith<$Res> get researchAgent;
  @override
  $CreativeDirectorAgentCopyWith<$Res> get creativeDirectorAgent;
  @override
  $AssetGenerationAgentCopyWith<$Res> get assetGenerationAgent;
  @override
  $AgentOrchestratorCopyWith<$Res> get orchestrator;
}

/// @nodoc
class __$$MultiAgentSystemImplCopyWithImpl<$Res>
    extends _$MultiAgentSystemCopyWithImpl<$Res, _$MultiAgentSystemImpl>
    implements _$$MultiAgentSystemImplCopyWith<$Res> {
  __$$MultiAgentSystemImplCopyWithImpl(
    _$MultiAgentSystemImpl _value,
    $Res Function(_$MultiAgentSystemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? researchAgent = null,
    Object? creativeDirectorAgent = null,
    Object? assetGenerationAgent = null,
    Object? orchestrator = null,
  }) {
    return _then(
      _$MultiAgentSystemImpl(
        researchAgent: null == researchAgent
            ? _value.researchAgent
            : researchAgent // ignore: cast_nullable_to_non_nullable
                  as ResearchAgent,
        creativeDirectorAgent: null == creativeDirectorAgent
            ? _value.creativeDirectorAgent
            : creativeDirectorAgent // ignore: cast_nullable_to_non_nullable
                  as CreativeDirectorAgent,
        assetGenerationAgent: null == assetGenerationAgent
            ? _value.assetGenerationAgent
            : assetGenerationAgent // ignore: cast_nullable_to_non_nullable
                  as AssetGenerationAgent,
        orchestrator: null == orchestrator
            ? _value.orchestrator
            : orchestrator // ignore: cast_nullable_to_non_nullable
                  as AgentOrchestrator,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$MultiAgentSystemImpl implements _MultiAgentSystem {
  const _$MultiAgentSystemImpl({
    required this.researchAgent,
    required this.creativeDirectorAgent,
    required this.assetGenerationAgent,
    required this.orchestrator,
  });

  factory _$MultiAgentSystemImpl.fromJson(Map<String, dynamic> json) =>
      _$$MultiAgentSystemImplFromJson(json);

  @override
  final ResearchAgent researchAgent;
  @override
  final CreativeDirectorAgent creativeDirectorAgent;
  @override
  final AssetGenerationAgent assetGenerationAgent;
  @override
  final AgentOrchestrator orchestrator;

  @override
  String toString() {
    return 'MultiAgentSystem(researchAgent: $researchAgent, creativeDirectorAgent: $creativeDirectorAgent, assetGenerationAgent: $assetGenerationAgent, orchestrator: $orchestrator)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultiAgentSystemImpl &&
            (identical(other.researchAgent, researchAgent) ||
                other.researchAgent == researchAgent) &&
            (identical(other.creativeDirectorAgent, creativeDirectorAgent) ||
                other.creativeDirectorAgent == creativeDirectorAgent) &&
            (identical(other.assetGenerationAgent, assetGenerationAgent) ||
                other.assetGenerationAgent == assetGenerationAgent) &&
            (identical(other.orchestrator, orchestrator) ||
                other.orchestrator == orchestrator));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    researchAgent,
    creativeDirectorAgent,
    assetGenerationAgent,
    orchestrator,
  );

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MultiAgentSystemImplCopyWith<_$MultiAgentSystemImpl> get copyWith =>
      __$$MultiAgentSystemImplCopyWithImpl<_$MultiAgentSystemImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$MultiAgentSystemImplToJson(this);
  }
}

abstract class _MultiAgentSystem implements MultiAgentSystem {
  const factory _MultiAgentSystem({
    required final ResearchAgent researchAgent,
    required final CreativeDirectorAgent creativeDirectorAgent,
    required final AssetGenerationAgent assetGenerationAgent,
    required final AgentOrchestrator orchestrator,
  }) = _$MultiAgentSystemImpl;

  factory _MultiAgentSystem.fromJson(Map<String, dynamic> json) =
      _$MultiAgentSystemImpl.fromJson;

  @override
  ResearchAgent get researchAgent;
  @override
  CreativeDirectorAgent get creativeDirectorAgent;
  @override
  AssetGenerationAgent get assetGenerationAgent;
  @override
  AgentOrchestrator get orchestrator;

  /// Create a copy of MultiAgentSystem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MultiAgentSystemImplCopyWith<_$MultiAgentSystemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ResearchAgent _$ResearchAgentFromJson(Map<String, dynamic> json) {
  return _ResearchAgent.fromJson(json);
}

/// @nodoc
mixin _$ResearchAgent {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AgentStatus get status => throw _privateConstructorUsedError;
  List<ResearchSource> get activeSources => throw _privateConstructorUsedError;
  List<EthicalConcern> get ethicalControls =>
      throw _privateConstructorUsedError;
  ResearchMetrics get metrics => throw _privateConstructorUsedError;
  AgentCapabilities get capabilities => throw _privateConstructorUsedError;

  /// Serializes this ResearchAgent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResearchAgentCopyWith<ResearchAgent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResearchAgentCopyWith<$Res> {
  factory $ResearchAgentCopyWith(
    ResearchAgent value,
    $Res Function(ResearchAgent) then,
  ) = _$ResearchAgentCopyWithImpl<$Res, ResearchAgent>;
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    List<ResearchSource> activeSources,
    List<EthicalConcern> ethicalControls,
    ResearchMetrics metrics,
    AgentCapabilities capabilities,
  });

  $ResearchMetricsCopyWith<$Res> get metrics;
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class _$ResearchAgentCopyWithImpl<$Res, $Val extends ResearchAgent>
    implements $ResearchAgentCopyWith<$Res> {
  _$ResearchAgentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? activeSources = null,
    Object? ethicalControls = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as AgentStatus,
            activeSources: null == activeSources
                ? _value.activeSources
                : activeSources // ignore: cast_nullable_to_non_nullable
                      as List<ResearchSource>,
            ethicalControls: null == ethicalControls
                ? _value.ethicalControls
                : ethicalControls // ignore: cast_nullable_to_non_nullable
                      as List<EthicalConcern>,
            metrics: null == metrics
                ? _value.metrics
                : metrics // ignore: cast_nullable_to_non_nullable
                      as ResearchMetrics,
            capabilities: null == capabilities
                ? _value.capabilities
                : capabilities // ignore: cast_nullable_to_non_nullable
                      as AgentCapabilities,
          )
          as $Val,
    );
  }

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResearchMetricsCopyWith<$Res> get metrics {
    return $ResearchMetricsCopyWith<$Res>(_value.metrics, (value) {
      return _then(_value.copyWith(metrics: value) as $Val);
    });
  }

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AgentCapabilitiesCopyWith<$Res> get capabilities {
    return $AgentCapabilitiesCopyWith<$Res>(_value.capabilities, (value) {
      return _then(_value.copyWith(capabilities: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ResearchAgentImplCopyWith<$Res>
    implements $ResearchAgentCopyWith<$Res> {
  factory _$$ResearchAgentImplCopyWith(
    _$ResearchAgentImpl value,
    $Res Function(_$ResearchAgentImpl) then,
  ) = __$$ResearchAgentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    List<ResearchSource> activeSources,
    List<EthicalConcern> ethicalControls,
    ResearchMetrics metrics,
    AgentCapabilities capabilities,
  });

  @override
  $ResearchMetricsCopyWith<$Res> get metrics;
  @override
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class __$$ResearchAgentImplCopyWithImpl<$Res>
    extends _$ResearchAgentCopyWithImpl<$Res, _$ResearchAgentImpl>
    implements _$$ResearchAgentImplCopyWith<$Res> {
  __$$ResearchAgentImplCopyWithImpl(
    _$ResearchAgentImpl _value,
    $Res Function(_$ResearchAgentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? activeSources = null,
    Object? ethicalControls = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _$ResearchAgentImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as AgentStatus,
        activeSources: null == activeSources
            ? _value._activeSources
            : activeSources // ignore: cast_nullable_to_non_nullable
                  as List<ResearchSource>,
        ethicalControls: null == ethicalControls
            ? _value._ethicalControls
            : ethicalControls // ignore: cast_nullable_to_non_nullable
                  as List<EthicalConcern>,
        metrics: null == metrics
            ? _value.metrics
            : metrics // ignore: cast_nullable_to_non_nullable
                  as ResearchMetrics,
        capabilities: null == capabilities
            ? _value.capabilities
            : capabilities // ignore: cast_nullable_to_non_nullable
                  as AgentCapabilities,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ResearchAgentImpl implements _ResearchAgent {
  const _$ResearchAgentImpl({
    required this.id,
    required this.name,
    required this.status,
    required final List<ResearchSource> activeSources,
    required final List<EthicalConcern> ethicalControls,
    required this.metrics,
    required this.capabilities,
  }) : _activeSources = activeSources,
       _ethicalControls = ethicalControls;

  factory _$ResearchAgentImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResearchAgentImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AgentStatus status;
  final List<ResearchSource> _activeSources;
  @override
  List<ResearchSource> get activeSources {
    if (_activeSources is EqualUnmodifiableListView) return _activeSources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_activeSources);
  }

  final List<EthicalConcern> _ethicalControls;
  @override
  List<EthicalConcern> get ethicalControls {
    if (_ethicalControls is EqualUnmodifiableListView) return _ethicalControls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_ethicalControls);
  }

  @override
  final ResearchMetrics metrics;
  @override
  final AgentCapabilities capabilities;

  @override
  String toString() {
    return 'ResearchAgent(id: $id, name: $name, status: $status, activeSources: $activeSources, ethicalControls: $ethicalControls, metrics: $metrics, capabilities: $capabilities)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResearchAgentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(
              other._activeSources,
              _activeSources,
            ) &&
            const DeepCollectionEquality().equals(
              other._ethicalControls,
              _ethicalControls,
            ) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.capabilities, capabilities) ||
                other.capabilities == capabilities));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    status,
    const DeepCollectionEquality().hash(_activeSources),
    const DeepCollectionEquality().hash(_ethicalControls),
    metrics,
    capabilities,
  );

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResearchAgentImplCopyWith<_$ResearchAgentImpl> get copyWith =>
      __$$ResearchAgentImplCopyWithImpl<_$ResearchAgentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ResearchAgentImplToJson(this);
  }
}

abstract class _ResearchAgent implements ResearchAgent {
  const factory _ResearchAgent({
    required final String id,
    required final String name,
    required final AgentStatus status,
    required final List<ResearchSource> activeSources,
    required final List<EthicalConcern> ethicalControls,
    required final ResearchMetrics metrics,
    required final AgentCapabilities capabilities,
  }) = _$ResearchAgentImpl;

  factory _ResearchAgent.fromJson(Map<String, dynamic> json) =
      _$ResearchAgentImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AgentStatus get status;
  @override
  List<ResearchSource> get activeSources;
  @override
  List<EthicalConcern> get ethicalControls;
  @override
  ResearchMetrics get metrics;
  @override
  AgentCapabilities get capabilities;

  /// Create a copy of ResearchAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResearchAgentImplCopyWith<_$ResearchAgentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreativeDirectorAgent _$CreativeDirectorAgentFromJson(
  Map<String, dynamic> json,
) {
  return _CreativeDirectorAgent.fromJson(json);
}

/// @nodoc
mixin _$CreativeDirectorAgent {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AgentStatus get status => throw _privateConstructorUsedError;
  GameDesignDocument get currentDesign => throw _privateConstructorUsedError;
  List<CreativeDomain> get domains => throw _privateConstructorUsedError;
  CreativeMetrics get metrics => throw _privateConstructorUsedError;
  AgentCapabilities get capabilities => throw _privateConstructorUsedError;

  /// Serializes this CreativeDirectorAgent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CreativeDirectorAgentCopyWith<CreativeDirectorAgent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreativeDirectorAgentCopyWith<$Res> {
  factory $CreativeDirectorAgentCopyWith(
    CreativeDirectorAgent value,
    $Res Function(CreativeDirectorAgent) then,
  ) = _$CreativeDirectorAgentCopyWithImpl<$Res, CreativeDirectorAgent>;
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    GameDesignDocument currentDesign,
    List<CreativeDomain> domains,
    CreativeMetrics metrics,
    AgentCapabilities capabilities,
  });

  $GameDesignDocumentCopyWith<$Res> get currentDesign;
  $CreativeMetricsCopyWith<$Res> get metrics;
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class _$CreativeDirectorAgentCopyWithImpl<
  $Res,
  $Val extends CreativeDirectorAgent
>
    implements $CreativeDirectorAgentCopyWith<$Res> {
  _$CreativeDirectorAgentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? currentDesign = null,
    Object? domains = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as AgentStatus,
            currentDesign: null == currentDesign
                ? _value.currentDesign
                : currentDesign // ignore: cast_nullable_to_non_nullable
                      as GameDesignDocument,
            domains: null == domains
                ? _value.domains
                : domains // ignore: cast_nullable_to_non_nullable
                      as List<CreativeDomain>,
            metrics: null == metrics
                ? _value.metrics
                : metrics // ignore: cast_nullable_to_non_nullable
                      as CreativeMetrics,
            capabilities: null == capabilities
                ? _value.capabilities
                : capabilities // ignore: cast_nullable_to_non_nullable
                      as AgentCapabilities,
          )
          as $Val,
    );
  }

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GameDesignDocumentCopyWith<$Res> get currentDesign {
    return $GameDesignDocumentCopyWith<$Res>(_value.currentDesign, (value) {
      return _then(_value.copyWith(currentDesign: value) as $Val);
    });
  }

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreativeMetricsCopyWith<$Res> get metrics {
    return $CreativeMetricsCopyWith<$Res>(_value.metrics, (value) {
      return _then(_value.copyWith(metrics: value) as $Val);
    });
  }

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AgentCapabilitiesCopyWith<$Res> get capabilities {
    return $AgentCapabilitiesCopyWith<$Res>(_value.capabilities, (value) {
      return _then(_value.copyWith(capabilities: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreativeDirectorAgentImplCopyWith<$Res>
    implements $CreativeDirectorAgentCopyWith<$Res> {
  factory _$$CreativeDirectorAgentImplCopyWith(
    _$CreativeDirectorAgentImpl value,
    $Res Function(_$CreativeDirectorAgentImpl) then,
  ) = __$$CreativeDirectorAgentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    GameDesignDocument currentDesign,
    List<CreativeDomain> domains,
    CreativeMetrics metrics,
    AgentCapabilities capabilities,
  });

  @override
  $GameDesignDocumentCopyWith<$Res> get currentDesign;
  @override
  $CreativeMetricsCopyWith<$Res> get metrics;
  @override
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class __$$CreativeDirectorAgentImplCopyWithImpl<$Res>
    extends
        _$CreativeDirectorAgentCopyWithImpl<$Res, _$CreativeDirectorAgentImpl>
    implements _$$CreativeDirectorAgentImplCopyWith<$Res> {
  __$$CreativeDirectorAgentImplCopyWithImpl(
    _$CreativeDirectorAgentImpl _value,
    $Res Function(_$CreativeDirectorAgentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? currentDesign = null,
    Object? domains = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _$CreativeDirectorAgentImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as AgentStatus,
        currentDesign: null == currentDesign
            ? _value.currentDesign
            : currentDesign // ignore: cast_nullable_to_non_nullable
                  as GameDesignDocument,
        domains: null == domains
            ? _value._domains
            : domains // ignore: cast_nullable_to_non_nullable
                  as List<CreativeDomain>,
        metrics: null == metrics
            ? _value.metrics
            : metrics // ignore: cast_nullable_to_non_nullable
                  as CreativeMetrics,
        capabilities: null == capabilities
            ? _value.capabilities
            : capabilities // ignore: cast_nullable_to_non_nullable
                  as AgentCapabilities,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CreativeDirectorAgentImpl implements _CreativeDirectorAgent {
  const _$CreativeDirectorAgentImpl({
    required this.id,
    required this.name,
    required this.status,
    required this.currentDesign,
    required final List<CreativeDomain> domains,
    required this.metrics,
    required this.capabilities,
  }) : _domains = domains;

  factory _$CreativeDirectorAgentImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreativeDirectorAgentImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AgentStatus status;
  @override
  final GameDesignDocument currentDesign;
  final List<CreativeDomain> _domains;
  @override
  List<CreativeDomain> get domains {
    if (_domains is EqualUnmodifiableListView) return _domains;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_domains);
  }

  @override
  final CreativeMetrics metrics;
  @override
  final AgentCapabilities capabilities;

  @override
  String toString() {
    return 'CreativeDirectorAgent(id: $id, name: $name, status: $status, currentDesign: $currentDesign, domains: $domains, metrics: $metrics, capabilities: $capabilities)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreativeDirectorAgentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.currentDesign, currentDesign) ||
                other.currentDesign == currentDesign) &&
            const DeepCollectionEquality().equals(other._domains, _domains) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.capabilities, capabilities) ||
                other.capabilities == capabilities));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    status,
    currentDesign,
    const DeepCollectionEquality().hash(_domains),
    metrics,
    capabilities,
  );

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreativeDirectorAgentImplCopyWith<_$CreativeDirectorAgentImpl>
  get copyWith =>
      __$$CreativeDirectorAgentImplCopyWithImpl<_$CreativeDirectorAgentImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$CreativeDirectorAgentImplToJson(this);
  }
}

abstract class _CreativeDirectorAgent implements CreativeDirectorAgent {
  const factory _CreativeDirectorAgent({
    required final String id,
    required final String name,
    required final AgentStatus status,
    required final GameDesignDocument currentDesign,
    required final List<CreativeDomain> domains,
    required final CreativeMetrics metrics,
    required final AgentCapabilities capabilities,
  }) = _$CreativeDirectorAgentImpl;

  factory _CreativeDirectorAgent.fromJson(Map<String, dynamic> json) =
      _$CreativeDirectorAgentImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AgentStatus get status;
  @override
  GameDesignDocument get currentDesign;
  @override
  List<CreativeDomain> get domains;
  @override
  CreativeMetrics get metrics;
  @override
  AgentCapabilities get capabilities;

  /// Create a copy of CreativeDirectorAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreativeDirectorAgentImplCopyWith<_$CreativeDirectorAgentImpl>
  get copyWith => throw _privateConstructorUsedError;
}

AssetGenerationAgent _$AssetGenerationAgentFromJson(Map<String, dynamic> json) {
  return _AssetGenerationAgent.fromJson(json);
}

/// @nodoc
mixin _$AssetGenerationAgent {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AgentStatus get status => throw _privateConstructorUsedError;
  List<AssetType> get supportedTypes => throw _privateConstructorUsedError;
  List<GenerationEngine> get engines => throw _privateConstructorUsedError;
  AssetMetrics get metrics => throw _privateConstructorUsedError;
  AgentCapabilities get capabilities => throw _privateConstructorUsedError;

  /// Serializes this AssetGenerationAgent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AssetGenerationAgentCopyWith<AssetGenerationAgent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetGenerationAgentCopyWith<$Res> {
  factory $AssetGenerationAgentCopyWith(
    AssetGenerationAgent value,
    $Res Function(AssetGenerationAgent) then,
  ) = _$AssetGenerationAgentCopyWithImpl<$Res, AssetGenerationAgent>;
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    List<AssetType> supportedTypes,
    List<GenerationEngine> engines,
    AssetMetrics metrics,
    AgentCapabilities capabilities,
  });

  $AssetMetricsCopyWith<$Res> get metrics;
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class _$AssetGenerationAgentCopyWithImpl<
  $Res,
  $Val extends AssetGenerationAgent
>
    implements $AssetGenerationAgentCopyWith<$Res> {
  _$AssetGenerationAgentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? supportedTypes = null,
    Object? engines = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as AgentStatus,
            supportedTypes: null == supportedTypes
                ? _value.supportedTypes
                : supportedTypes // ignore: cast_nullable_to_non_nullable
                      as List<AssetType>,
            engines: null == engines
                ? _value.engines
                : engines // ignore: cast_nullable_to_non_nullable
                      as List<GenerationEngine>,
            metrics: null == metrics
                ? _value.metrics
                : metrics // ignore: cast_nullable_to_non_nullable
                      as AssetMetrics,
            capabilities: null == capabilities
                ? _value.capabilities
                : capabilities // ignore: cast_nullable_to_non_nullable
                      as AgentCapabilities,
          )
          as $Val,
    );
  }

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssetMetricsCopyWith<$Res> get metrics {
    return $AssetMetricsCopyWith<$Res>(_value.metrics, (value) {
      return _then(_value.copyWith(metrics: value) as $Val);
    });
  }

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AgentCapabilitiesCopyWith<$Res> get capabilities {
    return $AgentCapabilitiesCopyWith<$Res>(_value.capabilities, (value) {
      return _then(_value.copyWith(capabilities: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AssetGenerationAgentImplCopyWith<$Res>
    implements $AssetGenerationAgentCopyWith<$Res> {
  factory _$$AssetGenerationAgentImplCopyWith(
    _$AssetGenerationAgentImpl value,
    $Res Function(_$AssetGenerationAgentImpl) then,
  ) = __$$AssetGenerationAgentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    List<AssetType> supportedTypes,
    List<GenerationEngine> engines,
    AssetMetrics metrics,
    AgentCapabilities capabilities,
  });

  @override
  $AssetMetricsCopyWith<$Res> get metrics;
  @override
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class __$$AssetGenerationAgentImplCopyWithImpl<$Res>
    extends _$AssetGenerationAgentCopyWithImpl<$Res, _$AssetGenerationAgentImpl>
    implements _$$AssetGenerationAgentImplCopyWith<$Res> {
  __$$AssetGenerationAgentImplCopyWithImpl(
    _$AssetGenerationAgentImpl _value,
    $Res Function(_$AssetGenerationAgentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? supportedTypes = null,
    Object? engines = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _$AssetGenerationAgentImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as AgentStatus,
        supportedTypes: null == supportedTypes
            ? _value._supportedTypes
            : supportedTypes // ignore: cast_nullable_to_non_nullable
                  as List<AssetType>,
        engines: null == engines
            ? _value._engines
            : engines // ignore: cast_nullable_to_non_nullable
                  as List<GenerationEngine>,
        metrics: null == metrics
            ? _value.metrics
            : metrics // ignore: cast_nullable_to_non_nullable
                  as AssetMetrics,
        capabilities: null == capabilities
            ? _value.capabilities
            : capabilities // ignore: cast_nullable_to_non_nullable
                  as AgentCapabilities,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AssetGenerationAgentImpl implements _AssetGenerationAgent {
  const _$AssetGenerationAgentImpl({
    required this.id,
    required this.name,
    required this.status,
    required final List<AssetType> supportedTypes,
    required final List<GenerationEngine> engines,
    required this.metrics,
    required this.capabilities,
  }) : _supportedTypes = supportedTypes,
       _engines = engines;

  factory _$AssetGenerationAgentImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssetGenerationAgentImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AgentStatus status;
  final List<AssetType> _supportedTypes;
  @override
  List<AssetType> get supportedTypes {
    if (_supportedTypes is EqualUnmodifiableListView) return _supportedTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_supportedTypes);
  }

  final List<GenerationEngine> _engines;
  @override
  List<GenerationEngine> get engines {
    if (_engines is EqualUnmodifiableListView) return _engines;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_engines);
  }

  @override
  final AssetMetrics metrics;
  @override
  final AgentCapabilities capabilities;

  @override
  String toString() {
    return 'AssetGenerationAgent(id: $id, name: $name, status: $status, supportedTypes: $supportedTypes, engines: $engines, metrics: $metrics, capabilities: $capabilities)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssetGenerationAgentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(
              other._supportedTypes,
              _supportedTypes,
            ) &&
            const DeepCollectionEquality().equals(other._engines, _engines) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.capabilities, capabilities) ||
                other.capabilities == capabilities));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    status,
    const DeepCollectionEquality().hash(_supportedTypes),
    const DeepCollectionEquality().hash(_engines),
    metrics,
    capabilities,
  );

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AssetGenerationAgentImplCopyWith<_$AssetGenerationAgentImpl>
  get copyWith =>
      __$$AssetGenerationAgentImplCopyWithImpl<_$AssetGenerationAgentImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AssetGenerationAgentImplToJson(this);
  }
}

abstract class _AssetGenerationAgent implements AssetGenerationAgent {
  const factory _AssetGenerationAgent({
    required final String id,
    required final String name,
    required final AgentStatus status,
    required final List<AssetType> supportedTypes,
    required final List<GenerationEngine> engines,
    required final AssetMetrics metrics,
    required final AgentCapabilities capabilities,
  }) = _$AssetGenerationAgentImpl;

  factory _AssetGenerationAgent.fromJson(Map<String, dynamic> json) =
      _$AssetGenerationAgentImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AgentStatus get status;
  @override
  List<AssetType> get supportedTypes;
  @override
  List<GenerationEngine> get engines;
  @override
  AssetMetrics get metrics;
  @override
  AgentCapabilities get capabilities;

  /// Create a copy of AssetGenerationAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AssetGenerationAgentImplCopyWith<_$AssetGenerationAgentImpl>
  get copyWith => throw _privateConstructorUsedError;
}

AgentOrchestrator _$AgentOrchestratorFromJson(Map<String, dynamic> json) {
  return _AgentOrchestrator.fromJson(json);
}

/// @nodoc
mixin _$AgentOrchestrator {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AgentStatus get status => throw _privateConstructorUsedError;
  WorkflowPipeline get pipeline => throw _privateConstructorUsedError;
  List<AgentCommunication> get communications =>
      throw _privateConstructorUsedError;
  OrchestratorMetrics get metrics => throw _privateConstructorUsedError;
  AgentCapabilities get capabilities => throw _privateConstructorUsedError;

  /// Serializes this AgentOrchestrator to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AgentOrchestratorCopyWith<AgentOrchestrator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AgentOrchestratorCopyWith<$Res> {
  factory $AgentOrchestratorCopyWith(
    AgentOrchestrator value,
    $Res Function(AgentOrchestrator) then,
  ) = _$AgentOrchestratorCopyWithImpl<$Res, AgentOrchestrator>;
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    WorkflowPipeline pipeline,
    List<AgentCommunication> communications,
    OrchestratorMetrics metrics,
    AgentCapabilities capabilities,
  });

  $WorkflowPipelineCopyWith<$Res> get pipeline;
  $OrchestratorMetricsCopyWith<$Res> get metrics;
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class _$AgentOrchestratorCopyWithImpl<$Res, $Val extends AgentOrchestrator>
    implements $AgentOrchestratorCopyWith<$Res> {
  _$AgentOrchestratorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? pipeline = null,
    Object? communications = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as AgentStatus,
            pipeline: null == pipeline
                ? _value.pipeline
                : pipeline // ignore: cast_nullable_to_non_nullable
                      as WorkflowPipeline,
            communications: null == communications
                ? _value.communications
                : communications // ignore: cast_nullable_to_non_nullable
                      as List<AgentCommunication>,
            metrics: null == metrics
                ? _value.metrics
                : metrics // ignore: cast_nullable_to_non_nullable
                      as OrchestratorMetrics,
            capabilities: null == capabilities
                ? _value.capabilities
                : capabilities // ignore: cast_nullable_to_non_nullable
                      as AgentCapabilities,
          )
          as $Val,
    );
  }

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WorkflowPipelineCopyWith<$Res> get pipeline {
    return $WorkflowPipelineCopyWith<$Res>(_value.pipeline, (value) {
      return _then(_value.copyWith(pipeline: value) as $Val);
    });
  }

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OrchestratorMetricsCopyWith<$Res> get metrics {
    return $OrchestratorMetricsCopyWith<$Res>(_value.metrics, (value) {
      return _then(_value.copyWith(metrics: value) as $Val);
    });
  }

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AgentCapabilitiesCopyWith<$Res> get capabilities {
    return $AgentCapabilitiesCopyWith<$Res>(_value.capabilities, (value) {
      return _then(_value.copyWith(capabilities: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AgentOrchestratorImplCopyWith<$Res>
    implements $AgentOrchestratorCopyWith<$Res> {
  factory _$$AgentOrchestratorImplCopyWith(
    _$AgentOrchestratorImpl value,
    $Res Function(_$AgentOrchestratorImpl) then,
  ) = __$$AgentOrchestratorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AgentStatus status,
    WorkflowPipeline pipeline,
    List<AgentCommunication> communications,
    OrchestratorMetrics metrics,
    AgentCapabilities capabilities,
  });

  @override
  $WorkflowPipelineCopyWith<$Res> get pipeline;
  @override
  $OrchestratorMetricsCopyWith<$Res> get metrics;
  @override
  $AgentCapabilitiesCopyWith<$Res> get capabilities;
}

/// @nodoc
class __$$AgentOrchestratorImplCopyWithImpl<$Res>
    extends _$AgentOrchestratorCopyWithImpl<$Res, _$AgentOrchestratorImpl>
    implements _$$AgentOrchestratorImplCopyWith<$Res> {
  __$$AgentOrchestratorImplCopyWithImpl(
    _$AgentOrchestratorImpl _value,
    $Res Function(_$AgentOrchestratorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? status = null,
    Object? pipeline = null,
    Object? communications = null,
    Object? metrics = null,
    Object? capabilities = null,
  }) {
    return _then(
      _$AgentOrchestratorImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as AgentStatus,
        pipeline: null == pipeline
            ? _value.pipeline
            : pipeline // ignore: cast_nullable_to_non_nullable
                  as WorkflowPipeline,
        communications: null == communications
            ? _value._communications
            : communications // ignore: cast_nullable_to_non_nullable
                  as List<AgentCommunication>,
        metrics: null == metrics
            ? _value.metrics
            : metrics // ignore: cast_nullable_to_non_nullable
                  as OrchestratorMetrics,
        capabilities: null == capabilities
            ? _value.capabilities
            : capabilities // ignore: cast_nullable_to_non_nullable
                  as AgentCapabilities,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AgentOrchestratorImpl implements _AgentOrchestrator {
  const _$AgentOrchestratorImpl({
    required this.id,
    required this.name,
    required this.status,
    required this.pipeline,
    required final List<AgentCommunication> communications,
    required this.metrics,
    required this.capabilities,
  }) : _communications = communications;

  factory _$AgentOrchestratorImpl.fromJson(Map<String, dynamic> json) =>
      _$$AgentOrchestratorImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AgentStatus status;
  @override
  final WorkflowPipeline pipeline;
  final List<AgentCommunication> _communications;
  @override
  List<AgentCommunication> get communications {
    if (_communications is EqualUnmodifiableListView) return _communications;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_communications);
  }

  @override
  final OrchestratorMetrics metrics;
  @override
  final AgentCapabilities capabilities;

  @override
  String toString() {
    return 'AgentOrchestrator(id: $id, name: $name, status: $status, pipeline: $pipeline, communications: $communications, metrics: $metrics, capabilities: $capabilities)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AgentOrchestratorImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.pipeline, pipeline) ||
                other.pipeline == pipeline) &&
            const DeepCollectionEquality().equals(
              other._communications,
              _communications,
            ) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.capabilities, capabilities) ||
                other.capabilities == capabilities));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    status,
    pipeline,
    const DeepCollectionEquality().hash(_communications),
    metrics,
    capabilities,
  );

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AgentOrchestratorImplCopyWith<_$AgentOrchestratorImpl> get copyWith =>
      __$$AgentOrchestratorImplCopyWithImpl<_$AgentOrchestratorImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AgentOrchestratorImplToJson(this);
  }
}

abstract class _AgentOrchestrator implements AgentOrchestrator {
  const factory _AgentOrchestrator({
    required final String id,
    required final String name,
    required final AgentStatus status,
    required final WorkflowPipeline pipeline,
    required final List<AgentCommunication> communications,
    required final OrchestratorMetrics metrics,
    required final AgentCapabilities capabilities,
  }) = _$AgentOrchestratorImpl;

  factory _AgentOrchestrator.fromJson(Map<String, dynamic> json) =
      _$AgentOrchestratorImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AgentStatus get status;
  @override
  WorkflowPipeline get pipeline;
  @override
  List<AgentCommunication> get communications;
  @override
  OrchestratorMetrics get metrics;
  @override
  AgentCapabilities get capabilities;

  /// Create a copy of AgentOrchestrator
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AgentOrchestratorImplCopyWith<_$AgentOrchestratorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ResearchSource _$ResearchSourceFromJson(Map<String, dynamic> json) {
  return _ResearchSource.fromJson(json);
}

/// @nodoc
mixin _$ResearchSource {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  bool get isEnabled => throw _privateConstructorUsedError;
  List<EthicalConcern> get ethicalConcerns =>
      throw _privateConstructorUsedError;
  int get priority => throw _privateConstructorUsedError;

  /// Serializes this ResearchSource to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ResearchSource
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResearchSourceCopyWith<ResearchSource> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResearchSourceCopyWith<$Res> {
  factory $ResearchSourceCopyWith(
    ResearchSource value,
    $Res Function(ResearchSource) then,
  ) = _$ResearchSourceCopyWithImpl<$Res, ResearchSource>;
  @useResult
  $Res call({
    String id,
    String name,
    String category,
    bool isEnabled,
    List<EthicalConcern> ethicalConcerns,
    int priority,
  });
}

/// @nodoc
class _$ResearchSourceCopyWithImpl<$Res, $Val extends ResearchSource>
    implements $ResearchSourceCopyWith<$Res> {
  _$ResearchSourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResearchSource
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = null,
    Object? isEnabled = null,
    Object? ethicalConcerns = null,
    Object? priority = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            category: null == category
                ? _value.category
                : category // ignore: cast_nullable_to_non_nullable
                      as String,
            isEnabled: null == isEnabled
                ? _value.isEnabled
                : isEnabled // ignore: cast_nullable_to_non_nullable
                      as bool,
            ethicalConcerns: null == ethicalConcerns
                ? _value.ethicalConcerns
                : ethicalConcerns // ignore: cast_nullable_to_non_nullable
                      as List<EthicalConcern>,
            priority: null == priority
                ? _value.priority
                : priority // ignore: cast_nullable_to_non_nullable
                      as int,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ResearchSourceImplCopyWith<$Res>
    implements $ResearchSourceCopyWith<$Res> {
  factory _$$ResearchSourceImplCopyWith(
    _$ResearchSourceImpl value,
    $Res Function(_$ResearchSourceImpl) then,
  ) = __$$ResearchSourceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    String category,
    bool isEnabled,
    List<EthicalConcern> ethicalConcerns,
    int priority,
  });
}

/// @nodoc
class __$$ResearchSourceImplCopyWithImpl<$Res>
    extends _$ResearchSourceCopyWithImpl<$Res, _$ResearchSourceImpl>
    implements _$$ResearchSourceImplCopyWith<$Res> {
  __$$ResearchSourceImplCopyWithImpl(
    _$ResearchSourceImpl _value,
    $Res Function(_$ResearchSourceImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ResearchSource
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = null,
    Object? isEnabled = null,
    Object? ethicalConcerns = null,
    Object? priority = null,
  }) {
    return _then(
      _$ResearchSourceImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        category: null == category
            ? _value.category
            : category // ignore: cast_nullable_to_non_nullable
                  as String,
        isEnabled: null == isEnabled
            ? _value.isEnabled
            : isEnabled // ignore: cast_nullable_to_non_nullable
                  as bool,
        ethicalConcerns: null == ethicalConcerns
            ? _value._ethicalConcerns
            : ethicalConcerns // ignore: cast_nullable_to_non_nullable
                  as List<EthicalConcern>,
        priority: null == priority
            ? _value.priority
            : priority // ignore: cast_nullable_to_non_nullable
                  as int,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ResearchSourceImpl implements _ResearchSource {
  const _$ResearchSourceImpl({
    required this.id,
    required this.name,
    required this.category,
    required this.isEnabled,
    required final List<EthicalConcern> ethicalConcerns,
    required this.priority,
  }) : _ethicalConcerns = ethicalConcerns;

  factory _$ResearchSourceImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResearchSourceImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String category;
  @override
  final bool isEnabled;
  final List<EthicalConcern> _ethicalConcerns;
  @override
  List<EthicalConcern> get ethicalConcerns {
    if (_ethicalConcerns is EqualUnmodifiableListView) return _ethicalConcerns;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_ethicalConcerns);
  }

  @override
  final int priority;

  @override
  String toString() {
    return 'ResearchSource(id: $id, name: $name, category: $category, isEnabled: $isEnabled, ethicalConcerns: $ethicalConcerns, priority: $priority)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResearchSourceImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            const DeepCollectionEquality().equals(
              other._ethicalConcerns,
              _ethicalConcerns,
            ) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    category,
    isEnabled,
    const DeepCollectionEquality().hash(_ethicalConcerns),
    priority,
  );

  /// Create a copy of ResearchSource
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResearchSourceImplCopyWith<_$ResearchSourceImpl> get copyWith =>
      __$$ResearchSourceImplCopyWithImpl<_$ResearchSourceImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ResearchSourceImplToJson(this);
  }
}

abstract class _ResearchSource implements ResearchSource {
  const factory _ResearchSource({
    required final String id,
    required final String name,
    required final String category,
    required final bool isEnabled,
    required final List<EthicalConcern> ethicalConcerns,
    required final int priority,
  }) = _$ResearchSourceImpl;

  factory _ResearchSource.fromJson(Map<String, dynamic> json) =
      _$ResearchSourceImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get category;
  @override
  bool get isEnabled;
  @override
  List<EthicalConcern> get ethicalConcerns;
  @override
  int get priority;

  /// Create a copy of ResearchSource
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResearchSourceImplCopyWith<_$ResearchSourceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GameDesignDocument _$GameDesignDocumentFromJson(Map<String, dynamic> json) {
  return _GameDesignDocument.fromJson(json);
}

/// @nodoc
mixin _$GameDesignDocument {
  String get title => throw _privateConstructorUsedError;
  String get genre => throw _privateConstructorUsedError;
  String get targetAudience => throw _privateConstructorUsedError;
  List<GameMechanic> get mechanics => throw _privateConstructorUsedError;
  NarrativeStructure get narrative => throw _privateConstructorUsedError;
  UXDesign get uxDesign => throw _privateConstructorUsedError;
  AccessibilityFeatures get accessibility => throw _privateConstructorUsedError;

  /// Serializes this GameDesignDocument to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GameDesignDocumentCopyWith<GameDesignDocument> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GameDesignDocumentCopyWith<$Res> {
  factory $GameDesignDocumentCopyWith(
    GameDesignDocument value,
    $Res Function(GameDesignDocument) then,
  ) = _$GameDesignDocumentCopyWithImpl<$Res, GameDesignDocument>;
  @useResult
  $Res call({
    String title,
    String genre,
    String targetAudience,
    List<GameMechanic> mechanics,
    NarrativeStructure narrative,
    UXDesign uxDesign,
    AccessibilityFeatures accessibility,
  });

  $NarrativeStructureCopyWith<$Res> get narrative;
  $UXDesignCopyWith<$Res> get uxDesign;
  $AccessibilityFeaturesCopyWith<$Res> get accessibility;
}

/// @nodoc
class _$GameDesignDocumentCopyWithImpl<$Res, $Val extends GameDesignDocument>
    implements $GameDesignDocumentCopyWith<$Res> {
  _$GameDesignDocumentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? genre = null,
    Object? targetAudience = null,
    Object? mechanics = null,
    Object? narrative = null,
    Object? uxDesign = null,
    Object? accessibility = null,
  }) {
    return _then(
      _value.copyWith(
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            genre: null == genre
                ? _value.genre
                : genre // ignore: cast_nullable_to_non_nullable
                      as String,
            targetAudience: null == targetAudience
                ? _value.targetAudience
                : targetAudience // ignore: cast_nullable_to_non_nullable
                      as String,
            mechanics: null == mechanics
                ? _value.mechanics
                : mechanics // ignore: cast_nullable_to_non_nullable
                      as List<GameMechanic>,
            narrative: null == narrative
                ? _value.narrative
                : narrative // ignore: cast_nullable_to_non_nullable
                      as NarrativeStructure,
            uxDesign: null == uxDesign
                ? _value.uxDesign
                : uxDesign // ignore: cast_nullable_to_non_nullable
                      as UXDesign,
            accessibility: null == accessibility
                ? _value.accessibility
                : accessibility // ignore: cast_nullable_to_non_nullable
                      as AccessibilityFeatures,
          )
          as $Val,
    );
  }

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $NarrativeStructureCopyWith<$Res> get narrative {
    return $NarrativeStructureCopyWith<$Res>(_value.narrative, (value) {
      return _then(_value.copyWith(narrative: value) as $Val);
    });
  }

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UXDesignCopyWith<$Res> get uxDesign {
    return $UXDesignCopyWith<$Res>(_value.uxDesign, (value) {
      return _then(_value.copyWith(uxDesign: value) as $Val);
    });
  }

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccessibilityFeaturesCopyWith<$Res> get accessibility {
    return $AccessibilityFeaturesCopyWith<$Res>(_value.accessibility, (value) {
      return _then(_value.copyWith(accessibility: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GameDesignDocumentImplCopyWith<$Res>
    implements $GameDesignDocumentCopyWith<$Res> {
  factory _$$GameDesignDocumentImplCopyWith(
    _$GameDesignDocumentImpl value,
    $Res Function(_$GameDesignDocumentImpl) then,
  ) = __$$GameDesignDocumentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String title,
    String genre,
    String targetAudience,
    List<GameMechanic> mechanics,
    NarrativeStructure narrative,
    UXDesign uxDesign,
    AccessibilityFeatures accessibility,
  });

  @override
  $NarrativeStructureCopyWith<$Res> get narrative;
  @override
  $UXDesignCopyWith<$Res> get uxDesign;
  @override
  $AccessibilityFeaturesCopyWith<$Res> get accessibility;
}

/// @nodoc
class __$$GameDesignDocumentImplCopyWithImpl<$Res>
    extends _$GameDesignDocumentCopyWithImpl<$Res, _$GameDesignDocumentImpl>
    implements _$$GameDesignDocumentImplCopyWith<$Res> {
  __$$GameDesignDocumentImplCopyWithImpl(
    _$GameDesignDocumentImpl _value,
    $Res Function(_$GameDesignDocumentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? genre = null,
    Object? targetAudience = null,
    Object? mechanics = null,
    Object? narrative = null,
    Object? uxDesign = null,
    Object? accessibility = null,
  }) {
    return _then(
      _$GameDesignDocumentImpl(
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        genre: null == genre
            ? _value.genre
            : genre // ignore: cast_nullable_to_non_nullable
                  as String,
        targetAudience: null == targetAudience
            ? _value.targetAudience
            : targetAudience // ignore: cast_nullable_to_non_nullable
                  as String,
        mechanics: null == mechanics
            ? _value._mechanics
            : mechanics // ignore: cast_nullable_to_non_nullable
                  as List<GameMechanic>,
        narrative: null == narrative
            ? _value.narrative
            : narrative // ignore: cast_nullable_to_non_nullable
                  as NarrativeStructure,
        uxDesign: null == uxDesign
            ? _value.uxDesign
            : uxDesign // ignore: cast_nullable_to_non_nullable
                  as UXDesign,
        accessibility: null == accessibility
            ? _value.accessibility
            : accessibility // ignore: cast_nullable_to_non_nullable
                  as AccessibilityFeatures,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$GameDesignDocumentImpl implements _GameDesignDocument {
  const _$GameDesignDocumentImpl({
    required this.title,
    required this.genre,
    required this.targetAudience,
    required final List<GameMechanic> mechanics,
    required this.narrative,
    required this.uxDesign,
    required this.accessibility,
  }) : _mechanics = mechanics;

  factory _$GameDesignDocumentImpl.fromJson(Map<String, dynamic> json) =>
      _$$GameDesignDocumentImplFromJson(json);

  @override
  final String title;
  @override
  final String genre;
  @override
  final String targetAudience;
  final List<GameMechanic> _mechanics;
  @override
  List<GameMechanic> get mechanics {
    if (_mechanics is EqualUnmodifiableListView) return _mechanics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mechanics);
  }

  @override
  final NarrativeStructure narrative;
  @override
  final UXDesign uxDesign;
  @override
  final AccessibilityFeatures accessibility;

  @override
  String toString() {
    return 'GameDesignDocument(title: $title, genre: $genre, targetAudience: $targetAudience, mechanics: $mechanics, narrative: $narrative, uxDesign: $uxDesign, accessibility: $accessibility)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GameDesignDocumentImpl &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.genre, genre) || other.genre == genre) &&
            (identical(other.targetAudience, targetAudience) ||
                other.targetAudience == targetAudience) &&
            const DeepCollectionEquality().equals(
              other._mechanics,
              _mechanics,
            ) &&
            (identical(other.narrative, narrative) ||
                other.narrative == narrative) &&
            (identical(other.uxDesign, uxDesign) ||
                other.uxDesign == uxDesign) &&
            (identical(other.accessibility, accessibility) ||
                other.accessibility == accessibility));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    title,
    genre,
    targetAudience,
    const DeepCollectionEquality().hash(_mechanics),
    narrative,
    uxDesign,
    accessibility,
  );

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GameDesignDocumentImplCopyWith<_$GameDesignDocumentImpl> get copyWith =>
      __$$GameDesignDocumentImplCopyWithImpl<_$GameDesignDocumentImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$GameDesignDocumentImplToJson(this);
  }
}

abstract class _GameDesignDocument implements GameDesignDocument {
  const factory _GameDesignDocument({
    required final String title,
    required final String genre,
    required final String targetAudience,
    required final List<GameMechanic> mechanics,
    required final NarrativeStructure narrative,
    required final UXDesign uxDesign,
    required final AccessibilityFeatures accessibility,
  }) = _$GameDesignDocumentImpl;

  factory _GameDesignDocument.fromJson(Map<String, dynamic> json) =
      _$GameDesignDocumentImpl.fromJson;

  @override
  String get title;
  @override
  String get genre;
  @override
  String get targetAudience;
  @override
  List<GameMechanic> get mechanics;
  @override
  NarrativeStructure get narrative;
  @override
  UXDesign get uxDesign;
  @override
  AccessibilityFeatures get accessibility;

  /// Create a copy of GameDesignDocument
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GameDesignDocumentImplCopyWith<_$GameDesignDocumentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GameMechanic _$GameMechanicFromJson(Map<String, dynamic> json) {
  return _GameMechanic.fromJson(json);
}

/// @nodoc
mixin _$GameMechanic {
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  MechanicType get type => throw _privateConstructorUsedError;
  double get complexity => throw _privateConstructorUsedError;
  List<String> get dependencies => throw _privateConstructorUsedError;

  /// Serializes this GameMechanic to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GameMechanic
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GameMechanicCopyWith<GameMechanic> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GameMechanicCopyWith<$Res> {
  factory $GameMechanicCopyWith(
    GameMechanic value,
    $Res Function(GameMechanic) then,
  ) = _$GameMechanicCopyWithImpl<$Res, GameMechanic>;
  @useResult
  $Res call({
    String name,
    String description,
    MechanicType type,
    double complexity,
    List<String> dependencies,
  });
}

/// @nodoc
class _$GameMechanicCopyWithImpl<$Res, $Val extends GameMechanic>
    implements $GameMechanicCopyWith<$Res> {
  _$GameMechanicCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GameMechanic
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = null,
    Object? type = null,
    Object? complexity = null,
    Object? dependencies = null,
  }) {
    return _then(
      _value.copyWith(
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as MechanicType,
            complexity: null == complexity
                ? _value.complexity
                : complexity // ignore: cast_nullable_to_non_nullable
                      as double,
            dependencies: null == dependencies
                ? _value.dependencies
                : dependencies // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$GameMechanicImplCopyWith<$Res>
    implements $GameMechanicCopyWith<$Res> {
  factory _$$GameMechanicImplCopyWith(
    _$GameMechanicImpl value,
    $Res Function(_$GameMechanicImpl) then,
  ) = __$$GameMechanicImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String name,
    String description,
    MechanicType type,
    double complexity,
    List<String> dependencies,
  });
}

/// @nodoc
class __$$GameMechanicImplCopyWithImpl<$Res>
    extends _$GameMechanicCopyWithImpl<$Res, _$GameMechanicImpl>
    implements _$$GameMechanicImplCopyWith<$Res> {
  __$$GameMechanicImplCopyWithImpl(
    _$GameMechanicImpl _value,
    $Res Function(_$GameMechanicImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of GameMechanic
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = null,
    Object? type = null,
    Object? complexity = null,
    Object? dependencies = null,
  }) {
    return _then(
      _$GameMechanicImpl(
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as MechanicType,
        complexity: null == complexity
            ? _value.complexity
            : complexity // ignore: cast_nullable_to_non_nullable
                  as double,
        dependencies: null == dependencies
            ? _value._dependencies
            : dependencies // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$GameMechanicImpl implements _GameMechanic {
  const _$GameMechanicImpl({
    required this.name,
    required this.description,
    required this.type,
    required this.complexity,
    required final List<String> dependencies,
  }) : _dependencies = dependencies;

  factory _$GameMechanicImpl.fromJson(Map<String, dynamic> json) =>
      _$$GameMechanicImplFromJson(json);

  @override
  final String name;
  @override
  final String description;
  @override
  final MechanicType type;
  @override
  final double complexity;
  final List<String> _dependencies;
  @override
  List<String> get dependencies {
    if (_dependencies is EqualUnmodifiableListView) return _dependencies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dependencies);
  }

  @override
  String toString() {
    return 'GameMechanic(name: $name, description: $description, type: $type, complexity: $complexity, dependencies: $dependencies)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GameMechanicImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.complexity, complexity) ||
                other.complexity == complexity) &&
            const DeepCollectionEquality().equals(
              other._dependencies,
              _dependencies,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    name,
    description,
    type,
    complexity,
    const DeepCollectionEquality().hash(_dependencies),
  );

  /// Create a copy of GameMechanic
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GameMechanicImplCopyWith<_$GameMechanicImpl> get copyWith =>
      __$$GameMechanicImplCopyWithImpl<_$GameMechanicImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GameMechanicImplToJson(this);
  }
}

abstract class _GameMechanic implements GameMechanic {
  const factory _GameMechanic({
    required final String name,
    required final String description,
    required final MechanicType type,
    required final double complexity,
    required final List<String> dependencies,
  }) = _$GameMechanicImpl;

  factory _GameMechanic.fromJson(Map<String, dynamic> json) =
      _$GameMechanicImpl.fromJson;

  @override
  String get name;
  @override
  String get description;
  @override
  MechanicType get type;
  @override
  double get complexity;
  @override
  List<String> get dependencies;

  /// Create a copy of GameMechanic
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GameMechanicImplCopyWith<_$GameMechanicImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NarrativeStructure _$NarrativeStructureFromJson(Map<String, dynamic> json) {
  return _NarrativeStructure.fromJson(json);
}

/// @nodoc
mixin _$NarrativeStructure {
  String get theme => throw _privateConstructorUsedError;
  String get setting => throw _privateConstructorUsedError;
  List<StoryBeat> get storyBeats => throw _privateConstructorUsedError;
  List<Character> get characters => throw _privateConstructorUsedError;
  NarrativeStyle get style => throw _privateConstructorUsedError;

  /// Serializes this NarrativeStructure to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NarrativeStructure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NarrativeStructureCopyWith<NarrativeStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NarrativeStructureCopyWith<$Res> {
  factory $NarrativeStructureCopyWith(
    NarrativeStructure value,
    $Res Function(NarrativeStructure) then,
  ) = _$NarrativeStructureCopyWithImpl<$Res, NarrativeStructure>;
  @useResult
  $Res call({
    String theme,
    String setting,
    List<StoryBeat> storyBeats,
    List<Character> characters,
    NarrativeStyle style,
  });
}

/// @nodoc
class _$NarrativeStructureCopyWithImpl<$Res, $Val extends NarrativeStructure>
    implements $NarrativeStructureCopyWith<$Res> {
  _$NarrativeStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NarrativeStructure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = null,
    Object? setting = null,
    Object? storyBeats = null,
    Object? characters = null,
    Object? style = null,
  }) {
    return _then(
      _value.copyWith(
            theme: null == theme
                ? _value.theme
                : theme // ignore: cast_nullable_to_non_nullable
                      as String,
            setting: null == setting
                ? _value.setting
                : setting // ignore: cast_nullable_to_non_nullable
                      as String,
            storyBeats: null == storyBeats
                ? _value.storyBeats
                : storyBeats // ignore: cast_nullable_to_non_nullable
                      as List<StoryBeat>,
            characters: null == characters
                ? _value.characters
                : characters // ignore: cast_nullable_to_non_nullable
                      as List<Character>,
            style: null == style
                ? _value.style
                : style // ignore: cast_nullable_to_non_nullable
                      as NarrativeStyle,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$NarrativeStructureImplCopyWith<$Res>
    implements $NarrativeStructureCopyWith<$Res> {
  factory _$$NarrativeStructureImplCopyWith(
    _$NarrativeStructureImpl value,
    $Res Function(_$NarrativeStructureImpl) then,
  ) = __$$NarrativeStructureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String theme,
    String setting,
    List<StoryBeat> storyBeats,
    List<Character> characters,
    NarrativeStyle style,
  });
}

/// @nodoc
class __$$NarrativeStructureImplCopyWithImpl<$Res>
    extends _$NarrativeStructureCopyWithImpl<$Res, _$NarrativeStructureImpl>
    implements _$$NarrativeStructureImplCopyWith<$Res> {
  __$$NarrativeStructureImplCopyWithImpl(
    _$NarrativeStructureImpl _value,
    $Res Function(_$NarrativeStructureImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of NarrativeStructure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = null,
    Object? setting = null,
    Object? storyBeats = null,
    Object? characters = null,
    Object? style = null,
  }) {
    return _then(
      _$NarrativeStructureImpl(
        theme: null == theme
            ? _value.theme
            : theme // ignore: cast_nullable_to_non_nullable
                  as String,
        setting: null == setting
            ? _value.setting
            : setting // ignore: cast_nullable_to_non_nullable
                  as String,
        storyBeats: null == storyBeats
            ? _value._storyBeats
            : storyBeats // ignore: cast_nullable_to_non_nullable
                  as List<StoryBeat>,
        characters: null == characters
            ? _value._characters
            : characters // ignore: cast_nullable_to_non_nullable
                  as List<Character>,
        style: null == style
            ? _value.style
            : style // ignore: cast_nullable_to_non_nullable
                  as NarrativeStyle,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$NarrativeStructureImpl implements _NarrativeStructure {
  const _$NarrativeStructureImpl({
    required this.theme,
    required this.setting,
    required final List<StoryBeat> storyBeats,
    required final List<Character> characters,
    required this.style,
  }) : _storyBeats = storyBeats,
       _characters = characters;

  factory _$NarrativeStructureImpl.fromJson(Map<String, dynamic> json) =>
      _$$NarrativeStructureImplFromJson(json);

  @override
  final String theme;
  @override
  final String setting;
  final List<StoryBeat> _storyBeats;
  @override
  List<StoryBeat> get storyBeats {
    if (_storyBeats is EqualUnmodifiableListView) return _storyBeats;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_storyBeats);
  }

  final List<Character> _characters;
  @override
  List<Character> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  final NarrativeStyle style;

  @override
  String toString() {
    return 'NarrativeStructure(theme: $theme, setting: $setting, storyBeats: $storyBeats, characters: $characters, style: $style)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NarrativeStructureImpl &&
            (identical(other.theme, theme) || other.theme == theme) &&
            (identical(other.setting, setting) || other.setting == setting) &&
            const DeepCollectionEquality().equals(
              other._storyBeats,
              _storyBeats,
            ) &&
            const DeepCollectionEquality().equals(
              other._characters,
              _characters,
            ) &&
            (identical(other.style, style) || other.style == style));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    theme,
    setting,
    const DeepCollectionEquality().hash(_storyBeats),
    const DeepCollectionEquality().hash(_characters),
    style,
  );

  /// Create a copy of NarrativeStructure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NarrativeStructureImplCopyWith<_$NarrativeStructureImpl> get copyWith =>
      __$$NarrativeStructureImplCopyWithImpl<_$NarrativeStructureImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$NarrativeStructureImplToJson(this);
  }
}

abstract class _NarrativeStructure implements NarrativeStructure {
  const factory _NarrativeStructure({
    required final String theme,
    required final String setting,
    required final List<StoryBeat> storyBeats,
    required final List<Character> characters,
    required final NarrativeStyle style,
  }) = _$NarrativeStructureImpl;

  factory _NarrativeStructure.fromJson(Map<String, dynamic> json) =
      _$NarrativeStructureImpl.fromJson;

  @override
  String get theme;
  @override
  String get setting;
  @override
  List<StoryBeat> get storyBeats;
  @override
  List<Character> get characters;
  @override
  NarrativeStyle get style;

  /// Create a copy of NarrativeStructure
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NarrativeStructureImplCopyWith<_$NarrativeStructureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StoryBeat _$StoryBeatFromJson(Map<String, dynamic> json) {
  return _StoryBeat.fromJson(json);
}

/// @nodoc
mixin _$StoryBeat {
  String get id => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  int get order => throw _privateConstructorUsedError;
  BeatType get type => throw _privateConstructorUsedError;
  List<String> get triggers => throw _privateConstructorUsedError;

  /// Serializes this StoryBeat to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StoryBeat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryBeatCopyWith<StoryBeat> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoryBeatCopyWith<$Res> {
  factory $StoryBeatCopyWith(StoryBeat value, $Res Function(StoryBeat) then) =
      _$StoryBeatCopyWithImpl<$Res, StoryBeat>;
  @useResult
  $Res call({
    String id,
    String description,
    int order,
    BeatType type,
    List<String> triggers,
  });
}

/// @nodoc
class _$StoryBeatCopyWithImpl<$Res, $Val extends StoryBeat>
    implements $StoryBeatCopyWith<$Res> {
  _$StoryBeatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoryBeat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? order = null,
    Object? type = null,
    Object? triggers = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            order: null == order
                ? _value.order
                : order // ignore: cast_nullable_to_non_nullable
                      as int,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as BeatType,
            triggers: null == triggers
                ? _value.triggers
                : triggers // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$StoryBeatImplCopyWith<$Res>
    implements $StoryBeatCopyWith<$Res> {
  factory _$$StoryBeatImplCopyWith(
    _$StoryBeatImpl value,
    $Res Function(_$StoryBeatImpl) then,
  ) = __$$StoryBeatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String description,
    int order,
    BeatType type,
    List<String> triggers,
  });
}

/// @nodoc
class __$$StoryBeatImplCopyWithImpl<$Res>
    extends _$StoryBeatCopyWithImpl<$Res, _$StoryBeatImpl>
    implements _$$StoryBeatImplCopyWith<$Res> {
  __$$StoryBeatImplCopyWithImpl(
    _$StoryBeatImpl _value,
    $Res Function(_$StoryBeatImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of StoryBeat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? order = null,
    Object? type = null,
    Object? triggers = null,
  }) {
    return _then(
      _$StoryBeatImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        order: null == order
            ? _value.order
            : order // ignore: cast_nullable_to_non_nullable
                  as int,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as BeatType,
        triggers: null == triggers
            ? _value._triggers
            : triggers // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$StoryBeatImpl implements _StoryBeat {
  const _$StoryBeatImpl({
    required this.id,
    required this.description,
    required this.order,
    required this.type,
    required final List<String> triggers,
  }) : _triggers = triggers;

  factory _$StoryBeatImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryBeatImplFromJson(json);

  @override
  final String id;
  @override
  final String description;
  @override
  final int order;
  @override
  final BeatType type;
  final List<String> _triggers;
  @override
  List<String> get triggers {
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_triggers);
  }

  @override
  String toString() {
    return 'StoryBeat(id: $id, description: $description, order: $order, type: $type, triggers: $triggers)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryBeatImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.order, order) || other.order == order) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    description,
    order,
    type,
    const DeepCollectionEquality().hash(_triggers),
  );

  /// Create a copy of StoryBeat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryBeatImplCopyWith<_$StoryBeatImpl> get copyWith =>
      __$$StoryBeatImplCopyWithImpl<_$StoryBeatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StoryBeatImplToJson(this);
  }
}

abstract class _StoryBeat implements StoryBeat {
  const factory _StoryBeat({
    required final String id,
    required final String description,
    required final int order,
    required final BeatType type,
    required final List<String> triggers,
  }) = _$StoryBeatImpl;

  factory _StoryBeat.fromJson(Map<String, dynamic> json) =
      _$StoryBeatImpl.fromJson;

  @override
  String get id;
  @override
  String get description;
  @override
  int get order;
  @override
  BeatType get type;
  @override
  List<String> get triggers;

  /// Create a copy of StoryBeat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryBeatImplCopyWith<_$StoryBeatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Character _$CharacterFromJson(Map<String, dynamic> json) {
  return _Character.fromJson(json);
}

/// @nodoc
mixin _$Character {
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  CharacterRole get role => throw _privateConstructorUsedError;
  List<String> get traits => throw _privateConstructorUsedError;
  CharacterArc get arc => throw _privateConstructorUsedError;

  /// Serializes this Character to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Character
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterCopyWith<Character> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterCopyWith<$Res> {
  factory $CharacterCopyWith(Character value, $Res Function(Character) then) =
      _$CharacterCopyWithImpl<$Res, Character>;
  @useResult
  $Res call({
    String name,
    String description,
    CharacterRole role,
    List<String> traits,
    CharacterArc arc,
  });
}

/// @nodoc
class _$CharacterCopyWithImpl<$Res, $Val extends Character>
    implements $CharacterCopyWith<$Res> {
  _$CharacterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Character
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = null,
    Object? role = null,
    Object? traits = null,
    Object? arc = null,
  }) {
    return _then(
      _value.copyWith(
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            role: null == role
                ? _value.role
                : role // ignore: cast_nullable_to_non_nullable
                      as CharacterRole,
            traits: null == traits
                ? _value.traits
                : traits // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            arc: null == arc
                ? _value.arc
                : arc // ignore: cast_nullable_to_non_nullable
                      as CharacterArc,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$CharacterImplCopyWith<$Res>
    implements $CharacterCopyWith<$Res> {
  factory _$$CharacterImplCopyWith(
    _$CharacterImpl value,
    $Res Function(_$CharacterImpl) then,
  ) = __$$CharacterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String name,
    String description,
    CharacterRole role,
    List<String> traits,
    CharacterArc arc,
  });
}

/// @nodoc
class __$$CharacterImplCopyWithImpl<$Res>
    extends _$CharacterCopyWithImpl<$Res, _$CharacterImpl>
    implements _$$CharacterImplCopyWith<$Res> {
  __$$CharacterImplCopyWithImpl(
    _$CharacterImpl _value,
    $Res Function(_$CharacterImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Character
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = null,
    Object? role = null,
    Object? traits = null,
    Object? arc = null,
  }) {
    return _then(
      _$CharacterImpl(
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        role: null == role
            ? _value.role
            : role // ignore: cast_nullable_to_non_nullable
                  as CharacterRole,
        traits: null == traits
            ? _value._traits
            : traits // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        arc: null == arc
            ? _value.arc
            : arc // ignore: cast_nullable_to_non_nullable
                  as CharacterArc,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterImpl implements _Character {
  const _$CharacterImpl({
    required this.name,
    required this.description,
    required this.role,
    required final List<String> traits,
    required this.arc,
  }) : _traits = traits;

  factory _$CharacterImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterImplFromJson(json);

  @override
  final String name;
  @override
  final String description;
  @override
  final CharacterRole role;
  final List<String> _traits;
  @override
  List<String> get traits {
    if (_traits is EqualUnmodifiableListView) return _traits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_traits);
  }

  @override
  final CharacterArc arc;

  @override
  String toString() {
    return 'Character(name: $name, description: $description, role: $role, traits: $traits, arc: $arc)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._traits, _traits) &&
            (identical(other.arc, arc) || other.arc == arc));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    name,
    description,
    role,
    const DeepCollectionEquality().hash(_traits),
    arc,
  );

  /// Create a copy of Character
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterImplCopyWith<_$CharacterImpl> get copyWith =>
      __$$CharacterImplCopyWithImpl<_$CharacterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterImplToJson(this);
  }
}

abstract class _Character implements Character {
  const factory _Character({
    required final String name,
    required final String description,
    required final CharacterRole role,
    required final List<String> traits,
    required final CharacterArc arc,
  }) = _$CharacterImpl;

  factory _Character.fromJson(Map<String, dynamic> json) =
      _$CharacterImpl.fromJson;

  @override
  String get name;
  @override
  String get description;
  @override
  CharacterRole get role;
  @override
  List<String> get traits;
  @override
  CharacterArc get arc;

  /// Create a copy of Character
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterImplCopyWith<_$CharacterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UXDesign _$UXDesignFromJson(Map<String, dynamic> json) {
  return _UXDesign.fromJson(json);
}

/// @nodoc
mixin _$UXDesign {
  String get targetPlatform => throw _privateConstructorUsedError;
  List<UIPattern> get patterns => throw _privateConstructorUsedError;
  AccessibilityLevel get accessibility => throw _privateConstructorUsedError;
  List<String> get userFlows => throw _privateConstructorUsedError;

  /// Serializes this UXDesign to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UXDesign
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UXDesignCopyWith<UXDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UXDesignCopyWith<$Res> {
  factory $UXDesignCopyWith(UXDesign value, $Res Function(UXDesign) then) =
      _$UXDesignCopyWithImpl<$Res, UXDesign>;
  @useResult
  $Res call({
    String targetPlatform,
    List<UIPattern> patterns,
    AccessibilityLevel accessibility,
    List<String> userFlows,
  });
}

/// @nodoc
class _$UXDesignCopyWithImpl<$Res, $Val extends UXDesign>
    implements $UXDesignCopyWith<$Res> {
  _$UXDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UXDesign
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? targetPlatform = null,
    Object? patterns = null,
    Object? accessibility = null,
    Object? userFlows = null,
  }) {
    return _then(
      _value.copyWith(
            targetPlatform: null == targetPlatform
                ? _value.targetPlatform
                : targetPlatform // ignore: cast_nullable_to_non_nullable
                      as String,
            patterns: null == patterns
                ? _value.patterns
                : patterns // ignore: cast_nullable_to_non_nullable
                      as List<UIPattern>,
            accessibility: null == accessibility
                ? _value.accessibility
                : accessibility // ignore: cast_nullable_to_non_nullable
                      as AccessibilityLevel,
            userFlows: null == userFlows
                ? _value.userFlows
                : userFlows // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$UXDesignImplCopyWith<$Res>
    implements $UXDesignCopyWith<$Res> {
  factory _$$UXDesignImplCopyWith(
    _$UXDesignImpl value,
    $Res Function(_$UXDesignImpl) then,
  ) = __$$UXDesignImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String targetPlatform,
    List<UIPattern> patterns,
    AccessibilityLevel accessibility,
    List<String> userFlows,
  });
}

/// @nodoc
class __$$UXDesignImplCopyWithImpl<$Res>
    extends _$UXDesignCopyWithImpl<$Res, _$UXDesignImpl>
    implements _$$UXDesignImplCopyWith<$Res> {
  __$$UXDesignImplCopyWithImpl(
    _$UXDesignImpl _value,
    $Res Function(_$UXDesignImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UXDesign
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? targetPlatform = null,
    Object? patterns = null,
    Object? accessibility = null,
    Object? userFlows = null,
  }) {
    return _then(
      _$UXDesignImpl(
        targetPlatform: null == targetPlatform
            ? _value.targetPlatform
            : targetPlatform // ignore: cast_nullable_to_non_nullable
                  as String,
        patterns: null == patterns
            ? _value._patterns
            : patterns // ignore: cast_nullable_to_non_nullable
                  as List<UIPattern>,
        accessibility: null == accessibility
            ? _value.accessibility
            : accessibility // ignore: cast_nullable_to_non_nullable
                  as AccessibilityLevel,
        userFlows: null == userFlows
            ? _value._userFlows
            : userFlows // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$UXDesignImpl implements _UXDesign {
  const _$UXDesignImpl({
    required this.targetPlatform,
    required final List<UIPattern> patterns,
    required this.accessibility,
    required final List<String> userFlows,
  }) : _patterns = patterns,
       _userFlows = userFlows;

  factory _$UXDesignImpl.fromJson(Map<String, dynamic> json) =>
      _$$UXDesignImplFromJson(json);

  @override
  final String targetPlatform;
  final List<UIPattern> _patterns;
  @override
  List<UIPattern> get patterns {
    if (_patterns is EqualUnmodifiableListView) return _patterns;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_patterns);
  }

  @override
  final AccessibilityLevel accessibility;
  final List<String> _userFlows;
  @override
  List<String> get userFlows {
    if (_userFlows is EqualUnmodifiableListView) return _userFlows;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userFlows);
  }

  @override
  String toString() {
    return 'UXDesign(targetPlatform: $targetPlatform, patterns: $patterns, accessibility: $accessibility, userFlows: $userFlows)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UXDesignImpl &&
            (identical(other.targetPlatform, targetPlatform) ||
                other.targetPlatform == targetPlatform) &&
            const DeepCollectionEquality().equals(other._patterns, _patterns) &&
            (identical(other.accessibility, accessibility) ||
                other.accessibility == accessibility) &&
            const DeepCollectionEquality().equals(
              other._userFlows,
              _userFlows,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    targetPlatform,
    const DeepCollectionEquality().hash(_patterns),
    accessibility,
    const DeepCollectionEquality().hash(_userFlows),
  );

  /// Create a copy of UXDesign
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UXDesignImplCopyWith<_$UXDesignImpl> get copyWith =>
      __$$UXDesignImplCopyWithImpl<_$UXDesignImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UXDesignImplToJson(this);
  }
}

abstract class _UXDesign implements UXDesign {
  const factory _UXDesign({
    required final String targetPlatform,
    required final List<UIPattern> patterns,
    required final AccessibilityLevel accessibility,
    required final List<String> userFlows,
  }) = _$UXDesignImpl;

  factory _UXDesign.fromJson(Map<String, dynamic> json) =
      _$UXDesignImpl.fromJson;

  @override
  String get targetPlatform;
  @override
  List<UIPattern> get patterns;
  @override
  AccessibilityLevel get accessibility;
  @override
  List<String> get userFlows;

  /// Create a copy of UXDesign
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UXDesignImplCopyWith<_$UXDesignImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccessibilityFeatures _$AccessibilityFeaturesFromJson(
  Map<String, dynamic> json,
) {
  return _AccessibilityFeatures.fromJson(json);
}

/// @nodoc
mixin _$AccessibilityFeatures {
  bool get screenReaderSupport => throw _privateConstructorUsedError;
  bool get keyboardNavigation => throw _privateConstructorUsedError;
  bool get colorBlindSupport => throw _privateConstructorUsedError;
  bool get hearingImpairedSupport => throw _privateConstructorUsedError;
  bool get motorImpairedSupport => throw _privateConstructorUsedError;
  List<String> get customFeatures => throw _privateConstructorUsedError;

  /// Serializes this AccessibilityFeatures to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AccessibilityFeatures
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccessibilityFeaturesCopyWith<AccessibilityFeatures> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessibilityFeaturesCopyWith<$Res> {
  factory $AccessibilityFeaturesCopyWith(
    AccessibilityFeatures value,
    $Res Function(AccessibilityFeatures) then,
  ) = _$AccessibilityFeaturesCopyWithImpl<$Res, AccessibilityFeatures>;
  @useResult
  $Res call({
    bool screenReaderSupport,
    bool keyboardNavigation,
    bool colorBlindSupport,
    bool hearingImpairedSupport,
    bool motorImpairedSupport,
    List<String> customFeatures,
  });
}

/// @nodoc
class _$AccessibilityFeaturesCopyWithImpl<
  $Res,
  $Val extends AccessibilityFeatures
>
    implements $AccessibilityFeaturesCopyWith<$Res> {
  _$AccessibilityFeaturesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccessibilityFeatures
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenReaderSupport = null,
    Object? keyboardNavigation = null,
    Object? colorBlindSupport = null,
    Object? hearingImpairedSupport = null,
    Object? motorImpairedSupport = null,
    Object? customFeatures = null,
  }) {
    return _then(
      _value.copyWith(
            screenReaderSupport: null == screenReaderSupport
                ? _value.screenReaderSupport
                : screenReaderSupport // ignore: cast_nullable_to_non_nullable
                      as bool,
            keyboardNavigation: null == keyboardNavigation
                ? _value.keyboardNavigation
                : keyboardNavigation // ignore: cast_nullable_to_non_nullable
                      as bool,
            colorBlindSupport: null == colorBlindSupport
                ? _value.colorBlindSupport
                : colorBlindSupport // ignore: cast_nullable_to_non_nullable
                      as bool,
            hearingImpairedSupport: null == hearingImpairedSupport
                ? _value.hearingImpairedSupport
                : hearingImpairedSupport // ignore: cast_nullable_to_non_nullable
                      as bool,
            motorImpairedSupport: null == motorImpairedSupport
                ? _value.motorImpairedSupport
                : motorImpairedSupport // ignore: cast_nullable_to_non_nullable
                      as bool,
            customFeatures: null == customFeatures
                ? _value.customFeatures
                : customFeatures // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AccessibilityFeaturesImplCopyWith<$Res>
    implements $AccessibilityFeaturesCopyWith<$Res> {
  factory _$$AccessibilityFeaturesImplCopyWith(
    _$AccessibilityFeaturesImpl value,
    $Res Function(_$AccessibilityFeaturesImpl) then,
  ) = __$$AccessibilityFeaturesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    bool screenReaderSupport,
    bool keyboardNavigation,
    bool colorBlindSupport,
    bool hearingImpairedSupport,
    bool motorImpairedSupport,
    List<String> customFeatures,
  });
}

/// @nodoc
class __$$AccessibilityFeaturesImplCopyWithImpl<$Res>
    extends
        _$AccessibilityFeaturesCopyWithImpl<$Res, _$AccessibilityFeaturesImpl>
    implements _$$AccessibilityFeaturesImplCopyWith<$Res> {
  __$$AccessibilityFeaturesImplCopyWithImpl(
    _$AccessibilityFeaturesImpl _value,
    $Res Function(_$AccessibilityFeaturesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AccessibilityFeatures
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenReaderSupport = null,
    Object? keyboardNavigation = null,
    Object? colorBlindSupport = null,
    Object? hearingImpairedSupport = null,
    Object? motorImpairedSupport = null,
    Object? customFeatures = null,
  }) {
    return _then(
      _$AccessibilityFeaturesImpl(
        screenReaderSupport: null == screenReaderSupport
            ? _value.screenReaderSupport
            : screenReaderSupport // ignore: cast_nullable_to_non_nullable
                  as bool,
        keyboardNavigation: null == keyboardNavigation
            ? _value.keyboardNavigation
            : keyboardNavigation // ignore: cast_nullable_to_non_nullable
                  as bool,
        colorBlindSupport: null == colorBlindSupport
            ? _value.colorBlindSupport
            : colorBlindSupport // ignore: cast_nullable_to_non_nullable
                  as bool,
        hearingImpairedSupport: null == hearingImpairedSupport
            ? _value.hearingImpairedSupport
            : hearingImpairedSupport // ignore: cast_nullable_to_non_nullable
                  as bool,
        motorImpairedSupport: null == motorImpairedSupport
            ? _value.motorImpairedSupport
            : motorImpairedSupport // ignore: cast_nullable_to_non_nullable
                  as bool,
        customFeatures: null == customFeatures
            ? _value._customFeatures
            : customFeatures // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AccessibilityFeaturesImpl implements _AccessibilityFeatures {
  const _$AccessibilityFeaturesImpl({
    required this.screenReaderSupport,
    required this.keyboardNavigation,
    required this.colorBlindSupport,
    required this.hearingImpairedSupport,
    required this.motorImpairedSupport,
    required final List<String> customFeatures,
  }) : _customFeatures = customFeatures;

  factory _$AccessibilityFeaturesImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccessibilityFeaturesImplFromJson(json);

  @override
  final bool screenReaderSupport;
  @override
  final bool keyboardNavigation;
  @override
  final bool colorBlindSupport;
  @override
  final bool hearingImpairedSupport;
  @override
  final bool motorImpairedSupport;
  final List<String> _customFeatures;
  @override
  List<String> get customFeatures {
    if (_customFeatures is EqualUnmodifiableListView) return _customFeatures;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_customFeatures);
  }

  @override
  String toString() {
    return 'AccessibilityFeatures(screenReaderSupport: $screenReaderSupport, keyboardNavigation: $keyboardNavigation, colorBlindSupport: $colorBlindSupport, hearingImpairedSupport: $hearingImpairedSupport, motorImpairedSupport: $motorImpairedSupport, customFeatures: $customFeatures)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccessibilityFeaturesImpl &&
            (identical(other.screenReaderSupport, screenReaderSupport) ||
                other.screenReaderSupport == screenReaderSupport) &&
            (identical(other.keyboardNavigation, keyboardNavigation) ||
                other.keyboardNavigation == keyboardNavigation) &&
            (identical(other.colorBlindSupport, colorBlindSupport) ||
                other.colorBlindSupport == colorBlindSupport) &&
            (identical(other.hearingImpairedSupport, hearingImpairedSupport) ||
                other.hearingImpairedSupport == hearingImpairedSupport) &&
            (identical(other.motorImpairedSupport, motorImpairedSupport) ||
                other.motorImpairedSupport == motorImpairedSupport) &&
            const DeepCollectionEquality().equals(
              other._customFeatures,
              _customFeatures,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    screenReaderSupport,
    keyboardNavigation,
    colorBlindSupport,
    hearingImpairedSupport,
    motorImpairedSupport,
    const DeepCollectionEquality().hash(_customFeatures),
  );

  /// Create a copy of AccessibilityFeatures
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccessibilityFeaturesImplCopyWith<_$AccessibilityFeaturesImpl>
  get copyWith =>
      __$$AccessibilityFeaturesImplCopyWithImpl<_$AccessibilityFeaturesImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AccessibilityFeaturesImplToJson(this);
  }
}

abstract class _AccessibilityFeatures implements AccessibilityFeatures {
  const factory _AccessibilityFeatures({
    required final bool screenReaderSupport,
    required final bool keyboardNavigation,
    required final bool colorBlindSupport,
    required final bool hearingImpairedSupport,
    required final bool motorImpairedSupport,
    required final List<String> customFeatures,
  }) = _$AccessibilityFeaturesImpl;

  factory _AccessibilityFeatures.fromJson(Map<String, dynamic> json) =
      _$AccessibilityFeaturesImpl.fromJson;

  @override
  bool get screenReaderSupport;
  @override
  bool get keyboardNavigation;
  @override
  bool get colorBlindSupport;
  @override
  bool get hearingImpairedSupport;
  @override
  bool get motorImpairedSupport;
  @override
  List<String> get customFeatures;

  /// Create a copy of AccessibilityFeatures
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccessibilityFeaturesImplCopyWith<_$AccessibilityFeaturesImpl>
  get copyWith => throw _privateConstructorUsedError;
}

WorkflowPipeline _$WorkflowPipelineFromJson(Map<String, dynamic> json) {
  return _WorkflowPipeline.fromJson(json);
}

/// @nodoc
mixin _$WorkflowPipeline {
  List<WorkflowStep> get steps => throw _privateConstructorUsedError;
  Map<String, dynamic> get configuration => throw _privateConstructorUsedError;
  PipelineStatus get status => throw _privateConstructorUsedError;

  /// Serializes this WorkflowPipeline to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkflowPipeline
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkflowPipelineCopyWith<WorkflowPipeline> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkflowPipelineCopyWith<$Res> {
  factory $WorkflowPipelineCopyWith(
    WorkflowPipeline value,
    $Res Function(WorkflowPipeline) then,
  ) = _$WorkflowPipelineCopyWithImpl<$Res, WorkflowPipeline>;
  @useResult
  $Res call({
    List<WorkflowStep> steps,
    Map<String, dynamic> configuration,
    PipelineStatus status,
  });
}

/// @nodoc
class _$WorkflowPipelineCopyWithImpl<$Res, $Val extends WorkflowPipeline>
    implements $WorkflowPipelineCopyWith<$Res> {
  _$WorkflowPipelineCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkflowPipeline
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? steps = null,
    Object? configuration = null,
    Object? status = null,
  }) {
    return _then(
      _value.copyWith(
            steps: null == steps
                ? _value.steps
                : steps // ignore: cast_nullable_to_non_nullable
                      as List<WorkflowStep>,
            configuration: null == configuration
                ? _value.configuration
                : configuration // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as PipelineStatus,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$WorkflowPipelineImplCopyWith<$Res>
    implements $WorkflowPipelineCopyWith<$Res> {
  factory _$$WorkflowPipelineImplCopyWith(
    _$WorkflowPipelineImpl value,
    $Res Function(_$WorkflowPipelineImpl) then,
  ) = __$$WorkflowPipelineImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<WorkflowStep> steps,
    Map<String, dynamic> configuration,
    PipelineStatus status,
  });
}

/// @nodoc
class __$$WorkflowPipelineImplCopyWithImpl<$Res>
    extends _$WorkflowPipelineCopyWithImpl<$Res, _$WorkflowPipelineImpl>
    implements _$$WorkflowPipelineImplCopyWith<$Res> {
  __$$WorkflowPipelineImplCopyWithImpl(
    _$WorkflowPipelineImpl _value,
    $Res Function(_$WorkflowPipelineImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of WorkflowPipeline
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? steps = null,
    Object? configuration = null,
    Object? status = null,
  }) {
    return _then(
      _$WorkflowPipelineImpl(
        steps: null == steps
            ? _value._steps
            : steps // ignore: cast_nullable_to_non_nullable
                  as List<WorkflowStep>,
        configuration: null == configuration
            ? _value._configuration
            : configuration // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as PipelineStatus,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkflowPipelineImpl implements _WorkflowPipeline {
  const _$WorkflowPipelineImpl({
    required final List<WorkflowStep> steps,
    required final Map<String, dynamic> configuration,
    required this.status,
  }) : _steps = steps,
       _configuration = configuration;

  factory _$WorkflowPipelineImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkflowPipelineImplFromJson(json);

  final List<WorkflowStep> _steps;
  @override
  List<WorkflowStep> get steps {
    if (_steps is EqualUnmodifiableListView) return _steps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_steps);
  }

  final Map<String, dynamic> _configuration;
  @override
  Map<String, dynamic> get configuration {
    if (_configuration is EqualUnmodifiableMapView) return _configuration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_configuration);
  }

  @override
  final PipelineStatus status;

  @override
  String toString() {
    return 'WorkflowPipeline(steps: $steps, configuration: $configuration, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkflowPipelineImpl &&
            const DeepCollectionEquality().equals(other._steps, _steps) &&
            const DeepCollectionEquality().equals(
              other._configuration,
              _configuration,
            ) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_steps),
    const DeepCollectionEquality().hash(_configuration),
    status,
  );

  /// Create a copy of WorkflowPipeline
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkflowPipelineImplCopyWith<_$WorkflowPipelineImpl> get copyWith =>
      __$$WorkflowPipelineImplCopyWithImpl<_$WorkflowPipelineImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkflowPipelineImplToJson(this);
  }
}

abstract class _WorkflowPipeline implements WorkflowPipeline {
  const factory _WorkflowPipeline({
    required final List<WorkflowStep> steps,
    required final Map<String, dynamic> configuration,
    required final PipelineStatus status,
  }) = _$WorkflowPipelineImpl;

  factory _WorkflowPipeline.fromJson(Map<String, dynamic> json) =
      _$WorkflowPipelineImpl.fromJson;

  @override
  List<WorkflowStep> get steps;
  @override
  Map<String, dynamic> get configuration;
  @override
  PipelineStatus get status;

  /// Create a copy of WorkflowPipeline
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkflowPipelineImplCopyWith<_$WorkflowPipelineImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

WorkflowStep _$WorkflowStepFromJson(Map<String, dynamic> json) {
  return _WorkflowStep.fromJson(json);
}

/// @nodoc
mixin _$WorkflowStep {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AgentType get agent => throw _privateConstructorUsedError;
  StepStatus get status => throw _privateConstructorUsedError;
  Map<String, dynamic> get input => throw _privateConstructorUsedError;
  Map<String, dynamic> get output => throw _privateConstructorUsedError;

  /// Serializes this WorkflowStep to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkflowStep
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkflowStepCopyWith<WorkflowStep> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkflowStepCopyWith<$Res> {
  factory $WorkflowStepCopyWith(
    WorkflowStep value,
    $Res Function(WorkflowStep) then,
  ) = _$WorkflowStepCopyWithImpl<$Res, WorkflowStep>;
  @useResult
  $Res call({
    String id,
    String name,
    AgentType agent,
    StepStatus status,
    Map<String, dynamic> input,
    Map<String, dynamic> output,
  });
}

/// @nodoc
class _$WorkflowStepCopyWithImpl<$Res, $Val extends WorkflowStep>
    implements $WorkflowStepCopyWith<$Res> {
  _$WorkflowStepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkflowStep
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? agent = null,
    Object? status = null,
    Object? input = null,
    Object? output = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            agent: null == agent
                ? _value.agent
                : agent // ignore: cast_nullable_to_non_nullable
                      as AgentType,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as StepStatus,
            input: null == input
                ? _value.input
                : input // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            output: null == output
                ? _value.output
                : output // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$WorkflowStepImplCopyWith<$Res>
    implements $WorkflowStepCopyWith<$Res> {
  factory _$$WorkflowStepImplCopyWith(
    _$WorkflowStepImpl value,
    $Res Function(_$WorkflowStepImpl) then,
  ) = __$$WorkflowStepImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AgentType agent,
    StepStatus status,
    Map<String, dynamic> input,
    Map<String, dynamic> output,
  });
}

/// @nodoc
class __$$WorkflowStepImplCopyWithImpl<$Res>
    extends _$WorkflowStepCopyWithImpl<$Res, _$WorkflowStepImpl>
    implements _$$WorkflowStepImplCopyWith<$Res> {
  __$$WorkflowStepImplCopyWithImpl(
    _$WorkflowStepImpl _value,
    $Res Function(_$WorkflowStepImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of WorkflowStep
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? agent = null,
    Object? status = null,
    Object? input = null,
    Object? output = null,
  }) {
    return _then(
      _$WorkflowStepImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        agent: null == agent
            ? _value.agent
            : agent // ignore: cast_nullable_to_non_nullable
                  as AgentType,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as StepStatus,
        input: null == input
            ? _value._input
            : input // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        output: null == output
            ? _value._output
            : output // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkflowStepImpl implements _WorkflowStep {
  const _$WorkflowStepImpl({
    required this.id,
    required this.name,
    required this.agent,
    required this.status,
    required final Map<String, dynamic> input,
    required final Map<String, dynamic> output,
  }) : _input = input,
       _output = output;

  factory _$WorkflowStepImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkflowStepImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AgentType agent;
  @override
  final StepStatus status;
  final Map<String, dynamic> _input;
  @override
  Map<String, dynamic> get input {
    if (_input is EqualUnmodifiableMapView) return _input;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_input);
  }

  final Map<String, dynamic> _output;
  @override
  Map<String, dynamic> get output {
    if (_output is EqualUnmodifiableMapView) return _output;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_output);
  }

  @override
  String toString() {
    return 'WorkflowStep(id: $id, name: $name, agent: $agent, status: $status, input: $input, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkflowStepImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.agent, agent) || other.agent == agent) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other._input, _input) &&
            const DeepCollectionEquality().equals(other._output, _output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    agent,
    status,
    const DeepCollectionEquality().hash(_input),
    const DeepCollectionEquality().hash(_output),
  );

  /// Create a copy of WorkflowStep
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkflowStepImplCopyWith<_$WorkflowStepImpl> get copyWith =>
      __$$WorkflowStepImplCopyWithImpl<_$WorkflowStepImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkflowStepImplToJson(this);
  }
}

abstract class _WorkflowStep implements WorkflowStep {
  const factory _WorkflowStep({
    required final String id,
    required final String name,
    required final AgentType agent,
    required final StepStatus status,
    required final Map<String, dynamic> input,
    required final Map<String, dynamic> output,
  }) = _$WorkflowStepImpl;

  factory _WorkflowStep.fromJson(Map<String, dynamic> json) =
      _$WorkflowStepImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AgentType get agent;
  @override
  StepStatus get status;
  @override
  Map<String, dynamic> get input;
  @override
  Map<String, dynamic> get output;

  /// Create a copy of WorkflowStep
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkflowStepImplCopyWith<_$WorkflowStepImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AgentCommunication _$AgentCommunicationFromJson(Map<String, dynamic> json) {
  return _AgentCommunication.fromJson(json);
}

/// @nodoc
mixin _$AgentCommunication {
  String get fromAgent => throw _privateConstructorUsedError;
  String get toAgent => throw _privateConstructorUsedError;
  CommunicationType get type => throw _privateConstructorUsedError;
  Map<String, dynamic> get data => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;

  /// Serializes this AgentCommunication to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AgentCommunication
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AgentCommunicationCopyWith<AgentCommunication> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AgentCommunicationCopyWith<$Res> {
  factory $AgentCommunicationCopyWith(
    AgentCommunication value,
    $Res Function(AgentCommunication) then,
  ) = _$AgentCommunicationCopyWithImpl<$Res, AgentCommunication>;
  @useResult
  $Res call({
    String fromAgent,
    String toAgent,
    CommunicationType type,
    Map<String, dynamic> data,
    DateTime timestamp,
  });
}

/// @nodoc
class _$AgentCommunicationCopyWithImpl<$Res, $Val extends AgentCommunication>
    implements $AgentCommunicationCopyWith<$Res> {
  _$AgentCommunicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AgentCommunication
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fromAgent = null,
    Object? toAgent = null,
    Object? type = null,
    Object? data = null,
    Object? timestamp = null,
  }) {
    return _then(
      _value.copyWith(
            fromAgent: null == fromAgent
                ? _value.fromAgent
                : fromAgent // ignore: cast_nullable_to_non_nullable
                      as String,
            toAgent: null == toAgent
                ? _value.toAgent
                : toAgent // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as CommunicationType,
            data: null == data
                ? _value.data
                : data // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            timestamp: null == timestamp
                ? _value.timestamp
                : timestamp // ignore: cast_nullable_to_non_nullable
                      as DateTime,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AgentCommunicationImplCopyWith<$Res>
    implements $AgentCommunicationCopyWith<$Res> {
  factory _$$AgentCommunicationImplCopyWith(
    _$AgentCommunicationImpl value,
    $Res Function(_$AgentCommunicationImpl) then,
  ) = __$$AgentCommunicationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String fromAgent,
    String toAgent,
    CommunicationType type,
    Map<String, dynamic> data,
    DateTime timestamp,
  });
}

/// @nodoc
class __$$AgentCommunicationImplCopyWithImpl<$Res>
    extends _$AgentCommunicationCopyWithImpl<$Res, _$AgentCommunicationImpl>
    implements _$$AgentCommunicationImplCopyWith<$Res> {
  __$$AgentCommunicationImplCopyWithImpl(
    _$AgentCommunicationImpl _value,
    $Res Function(_$AgentCommunicationImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AgentCommunication
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fromAgent = null,
    Object? toAgent = null,
    Object? type = null,
    Object? data = null,
    Object? timestamp = null,
  }) {
    return _then(
      _$AgentCommunicationImpl(
        fromAgent: null == fromAgent
            ? _value.fromAgent
            : fromAgent // ignore: cast_nullable_to_non_nullable
                  as String,
        toAgent: null == toAgent
            ? _value.toAgent
            : toAgent // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as CommunicationType,
        data: null == data
            ? _value._data
            : data // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        timestamp: null == timestamp
            ? _value.timestamp
            : timestamp // ignore: cast_nullable_to_non_nullable
                  as DateTime,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AgentCommunicationImpl implements _AgentCommunication {
  const _$AgentCommunicationImpl({
    required this.fromAgent,
    required this.toAgent,
    required this.type,
    required final Map<String, dynamic> data,
    required this.timestamp,
  }) : _data = data;

  factory _$AgentCommunicationImpl.fromJson(Map<String, dynamic> json) =>
      _$$AgentCommunicationImplFromJson(json);

  @override
  final String fromAgent;
  @override
  final String toAgent;
  @override
  final CommunicationType type;
  final Map<String, dynamic> _data;
  @override
  Map<String, dynamic> get data {
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_data);
  }

  @override
  final DateTime timestamp;

  @override
  String toString() {
    return 'AgentCommunication(fromAgent: $fromAgent, toAgent: $toAgent, type: $type, data: $data, timestamp: $timestamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AgentCommunicationImpl &&
            (identical(other.fromAgent, fromAgent) ||
                other.fromAgent == fromAgent) &&
            (identical(other.toAgent, toAgent) || other.toAgent == toAgent) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    fromAgent,
    toAgent,
    type,
    const DeepCollectionEquality().hash(_data),
    timestamp,
  );

  /// Create a copy of AgentCommunication
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AgentCommunicationImplCopyWith<_$AgentCommunicationImpl> get copyWith =>
      __$$AgentCommunicationImplCopyWithImpl<_$AgentCommunicationImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AgentCommunicationImplToJson(this);
  }
}

abstract class _AgentCommunication implements AgentCommunication {
  const factory _AgentCommunication({
    required final String fromAgent,
    required final String toAgent,
    required final CommunicationType type,
    required final Map<String, dynamic> data,
    required final DateTime timestamp,
  }) = _$AgentCommunicationImpl;

  factory _AgentCommunication.fromJson(Map<String, dynamic> json) =
      _$AgentCommunicationImpl.fromJson;

  @override
  String get fromAgent;
  @override
  String get toAgent;
  @override
  CommunicationType get type;
  @override
  Map<String, dynamic> get data;
  @override
  DateTime get timestamp;

  /// Create a copy of AgentCommunication
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AgentCommunicationImplCopyWith<_$AgentCommunicationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AgentCapabilities _$AgentCapabilitiesFromJson(Map<String, dynamic> json) {
  return _AgentCapabilities.fromJson(json);
}

/// @nodoc
mixin _$AgentCapabilities {
  List<String> get supportedInputs => throw _privateConstructorUsedError;
  List<String> get supportedOutputs => throw _privateConstructorUsedError;
  Map<String, dynamic> get configuration => throw _privateConstructorUsedError;
  List<String> get limitations => throw _privateConstructorUsedError;

  /// Serializes this AgentCapabilities to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AgentCapabilities
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AgentCapabilitiesCopyWith<AgentCapabilities> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AgentCapabilitiesCopyWith<$Res> {
  factory $AgentCapabilitiesCopyWith(
    AgentCapabilities value,
    $Res Function(AgentCapabilities) then,
  ) = _$AgentCapabilitiesCopyWithImpl<$Res, AgentCapabilities>;
  @useResult
  $Res call({
    List<String> supportedInputs,
    List<String> supportedOutputs,
    Map<String, dynamic> configuration,
    List<String> limitations,
  });
}

/// @nodoc
class _$AgentCapabilitiesCopyWithImpl<$Res, $Val extends AgentCapabilities>
    implements $AgentCapabilitiesCopyWith<$Res> {
  _$AgentCapabilitiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AgentCapabilities
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? supportedInputs = null,
    Object? supportedOutputs = null,
    Object? configuration = null,
    Object? limitations = null,
  }) {
    return _then(
      _value.copyWith(
            supportedInputs: null == supportedInputs
                ? _value.supportedInputs
                : supportedInputs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            supportedOutputs: null == supportedOutputs
                ? _value.supportedOutputs
                : supportedOutputs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            configuration: null == configuration
                ? _value.configuration
                : configuration // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            limitations: null == limitations
                ? _value.limitations
                : limitations // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AgentCapabilitiesImplCopyWith<$Res>
    implements $AgentCapabilitiesCopyWith<$Res> {
  factory _$$AgentCapabilitiesImplCopyWith(
    _$AgentCapabilitiesImpl value,
    $Res Function(_$AgentCapabilitiesImpl) then,
  ) = __$$AgentCapabilitiesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<String> supportedInputs,
    List<String> supportedOutputs,
    Map<String, dynamic> configuration,
    List<String> limitations,
  });
}

/// @nodoc
class __$$AgentCapabilitiesImplCopyWithImpl<$Res>
    extends _$AgentCapabilitiesCopyWithImpl<$Res, _$AgentCapabilitiesImpl>
    implements _$$AgentCapabilitiesImplCopyWith<$Res> {
  __$$AgentCapabilitiesImplCopyWithImpl(
    _$AgentCapabilitiesImpl _value,
    $Res Function(_$AgentCapabilitiesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AgentCapabilities
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? supportedInputs = null,
    Object? supportedOutputs = null,
    Object? configuration = null,
    Object? limitations = null,
  }) {
    return _then(
      _$AgentCapabilitiesImpl(
        supportedInputs: null == supportedInputs
            ? _value._supportedInputs
            : supportedInputs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        supportedOutputs: null == supportedOutputs
            ? _value._supportedOutputs
            : supportedOutputs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        configuration: null == configuration
            ? _value._configuration
            : configuration // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        limitations: null == limitations
            ? _value._limitations
            : limitations // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AgentCapabilitiesImpl implements _AgentCapabilities {
  const _$AgentCapabilitiesImpl({
    required final List<String> supportedInputs,
    required final List<String> supportedOutputs,
    required final Map<String, dynamic> configuration,
    required final List<String> limitations,
  }) : _supportedInputs = supportedInputs,
       _supportedOutputs = supportedOutputs,
       _configuration = configuration,
       _limitations = limitations;

  factory _$AgentCapabilitiesImpl.fromJson(Map<String, dynamic> json) =>
      _$$AgentCapabilitiesImplFromJson(json);

  final List<String> _supportedInputs;
  @override
  List<String> get supportedInputs {
    if (_supportedInputs is EqualUnmodifiableListView) return _supportedInputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_supportedInputs);
  }

  final List<String> _supportedOutputs;
  @override
  List<String> get supportedOutputs {
    if (_supportedOutputs is EqualUnmodifiableListView)
      return _supportedOutputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_supportedOutputs);
  }

  final Map<String, dynamic> _configuration;
  @override
  Map<String, dynamic> get configuration {
    if (_configuration is EqualUnmodifiableMapView) return _configuration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_configuration);
  }

  final List<String> _limitations;
  @override
  List<String> get limitations {
    if (_limitations is EqualUnmodifiableListView) return _limitations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_limitations);
  }

  @override
  String toString() {
    return 'AgentCapabilities(supportedInputs: $supportedInputs, supportedOutputs: $supportedOutputs, configuration: $configuration, limitations: $limitations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AgentCapabilitiesImpl &&
            const DeepCollectionEquality().equals(
              other._supportedInputs,
              _supportedInputs,
            ) &&
            const DeepCollectionEquality().equals(
              other._supportedOutputs,
              _supportedOutputs,
            ) &&
            const DeepCollectionEquality().equals(
              other._configuration,
              _configuration,
            ) &&
            const DeepCollectionEquality().equals(
              other._limitations,
              _limitations,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_supportedInputs),
    const DeepCollectionEquality().hash(_supportedOutputs),
    const DeepCollectionEquality().hash(_configuration),
    const DeepCollectionEquality().hash(_limitations),
  );

  /// Create a copy of AgentCapabilities
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AgentCapabilitiesImplCopyWith<_$AgentCapabilitiesImpl> get copyWith =>
      __$$AgentCapabilitiesImplCopyWithImpl<_$AgentCapabilitiesImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AgentCapabilitiesImplToJson(this);
  }
}

abstract class _AgentCapabilities implements AgentCapabilities {
  const factory _AgentCapabilities({
    required final List<String> supportedInputs,
    required final List<String> supportedOutputs,
    required final Map<String, dynamic> configuration,
    required final List<String> limitations,
  }) = _$AgentCapabilitiesImpl;

  factory _AgentCapabilities.fromJson(Map<String, dynamic> json) =
      _$AgentCapabilitiesImpl.fromJson;

  @override
  List<String> get supportedInputs;
  @override
  List<String> get supportedOutputs;
  @override
  Map<String, dynamic> get configuration;
  @override
  List<String> get limitations;

  /// Create a copy of AgentCapabilities
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AgentCapabilitiesImplCopyWith<_$AgentCapabilitiesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ResearchMetrics _$ResearchMetricsFromJson(Map<String, dynamic> json) {
  return _ResearchMetrics.fromJson(json);
}

/// @nodoc
mixin _$ResearchMetrics {
  int get totalSources => throw _privateConstructorUsedError;
  int get activeSources => throw _privateConstructorUsedError;
  int get queriesProcessed => throw _privateConstructorUsedError;
  double get averageResponseTime => throw _privateConstructorUsedError;
  List<String> get topSources => throw _privateConstructorUsedError;

  /// Serializes this ResearchMetrics to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ResearchMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResearchMetricsCopyWith<ResearchMetrics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResearchMetricsCopyWith<$Res> {
  factory $ResearchMetricsCopyWith(
    ResearchMetrics value,
    $Res Function(ResearchMetrics) then,
  ) = _$ResearchMetricsCopyWithImpl<$Res, ResearchMetrics>;
  @useResult
  $Res call({
    int totalSources,
    int activeSources,
    int queriesProcessed,
    double averageResponseTime,
    List<String> topSources,
  });
}

/// @nodoc
class _$ResearchMetricsCopyWithImpl<$Res, $Val extends ResearchMetrics>
    implements $ResearchMetricsCopyWith<$Res> {
  _$ResearchMetricsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResearchMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalSources = null,
    Object? activeSources = null,
    Object? queriesProcessed = null,
    Object? averageResponseTime = null,
    Object? topSources = null,
  }) {
    return _then(
      _value.copyWith(
            totalSources: null == totalSources
                ? _value.totalSources
                : totalSources // ignore: cast_nullable_to_non_nullable
                      as int,
            activeSources: null == activeSources
                ? _value.activeSources
                : activeSources // ignore: cast_nullable_to_non_nullable
                      as int,
            queriesProcessed: null == queriesProcessed
                ? _value.queriesProcessed
                : queriesProcessed // ignore: cast_nullable_to_non_nullable
                      as int,
            averageResponseTime: null == averageResponseTime
                ? _value.averageResponseTime
                : averageResponseTime // ignore: cast_nullable_to_non_nullable
                      as double,
            topSources: null == topSources
                ? _value.topSources
                : topSources // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ResearchMetricsImplCopyWith<$Res>
    implements $ResearchMetricsCopyWith<$Res> {
  factory _$$ResearchMetricsImplCopyWith(
    _$ResearchMetricsImpl value,
    $Res Function(_$ResearchMetricsImpl) then,
  ) = __$$ResearchMetricsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int totalSources,
    int activeSources,
    int queriesProcessed,
    double averageResponseTime,
    List<String> topSources,
  });
}

/// @nodoc
class __$$ResearchMetricsImplCopyWithImpl<$Res>
    extends _$ResearchMetricsCopyWithImpl<$Res, _$ResearchMetricsImpl>
    implements _$$ResearchMetricsImplCopyWith<$Res> {
  __$$ResearchMetricsImplCopyWithImpl(
    _$ResearchMetricsImpl _value,
    $Res Function(_$ResearchMetricsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ResearchMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalSources = null,
    Object? activeSources = null,
    Object? queriesProcessed = null,
    Object? averageResponseTime = null,
    Object? topSources = null,
  }) {
    return _then(
      _$ResearchMetricsImpl(
        totalSources: null == totalSources
            ? _value.totalSources
            : totalSources // ignore: cast_nullable_to_non_nullable
                  as int,
        activeSources: null == activeSources
            ? _value.activeSources
            : activeSources // ignore: cast_nullable_to_non_nullable
                  as int,
        queriesProcessed: null == queriesProcessed
            ? _value.queriesProcessed
            : queriesProcessed // ignore: cast_nullable_to_non_nullable
                  as int,
        averageResponseTime: null == averageResponseTime
            ? _value.averageResponseTime
            : averageResponseTime // ignore: cast_nullable_to_non_nullable
                  as double,
        topSources: null == topSources
            ? _value._topSources
            : topSources // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ResearchMetricsImpl implements _ResearchMetrics {
  const _$ResearchMetricsImpl({
    required this.totalSources,
    required this.activeSources,
    required this.queriesProcessed,
    required this.averageResponseTime,
    required final List<String> topSources,
  }) : _topSources = topSources;

  factory _$ResearchMetricsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResearchMetricsImplFromJson(json);

  @override
  final int totalSources;
  @override
  final int activeSources;
  @override
  final int queriesProcessed;
  @override
  final double averageResponseTime;
  final List<String> _topSources;
  @override
  List<String> get topSources {
    if (_topSources is EqualUnmodifiableListView) return _topSources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topSources);
  }

  @override
  String toString() {
    return 'ResearchMetrics(totalSources: $totalSources, activeSources: $activeSources, queriesProcessed: $queriesProcessed, averageResponseTime: $averageResponseTime, topSources: $topSources)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResearchMetricsImpl &&
            (identical(other.totalSources, totalSources) ||
                other.totalSources == totalSources) &&
            (identical(other.activeSources, activeSources) ||
                other.activeSources == activeSources) &&
            (identical(other.queriesProcessed, queriesProcessed) ||
                other.queriesProcessed == queriesProcessed) &&
            (identical(other.averageResponseTime, averageResponseTime) ||
                other.averageResponseTime == averageResponseTime) &&
            const DeepCollectionEquality().equals(
              other._topSources,
              _topSources,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    totalSources,
    activeSources,
    queriesProcessed,
    averageResponseTime,
    const DeepCollectionEquality().hash(_topSources),
  );

  /// Create a copy of ResearchMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResearchMetricsImplCopyWith<_$ResearchMetricsImpl> get copyWith =>
      __$$ResearchMetricsImplCopyWithImpl<_$ResearchMetricsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ResearchMetricsImplToJson(this);
  }
}

abstract class _ResearchMetrics implements ResearchMetrics {
  const factory _ResearchMetrics({
    required final int totalSources,
    required final int activeSources,
    required final int queriesProcessed,
    required final double averageResponseTime,
    required final List<String> topSources,
  }) = _$ResearchMetricsImpl;

  factory _ResearchMetrics.fromJson(Map<String, dynamic> json) =
      _$ResearchMetricsImpl.fromJson;

  @override
  int get totalSources;
  @override
  int get activeSources;
  @override
  int get queriesProcessed;
  @override
  double get averageResponseTime;
  @override
  List<String> get topSources;

  /// Create a copy of ResearchMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResearchMetricsImplCopyWith<_$ResearchMetricsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreativeMetrics _$CreativeMetricsFromJson(Map<String, dynamic> json) {
  return _CreativeMetrics.fromJson(json);
}

/// @nodoc
mixin _$CreativeMetrics {
  int get designsCreated => throw _privateConstructorUsedError;
  int get mechanicsGenerated => throw _privateConstructorUsedError;
  int get narrativesWritten => throw _privateConstructorUsedError;
  double get creativityScore => throw _privateConstructorUsedError;
  List<String> get popularGenres => throw _privateConstructorUsedError;

  /// Serializes this CreativeMetrics to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CreativeMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CreativeMetricsCopyWith<CreativeMetrics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreativeMetricsCopyWith<$Res> {
  factory $CreativeMetricsCopyWith(
    CreativeMetrics value,
    $Res Function(CreativeMetrics) then,
  ) = _$CreativeMetricsCopyWithImpl<$Res, CreativeMetrics>;
  @useResult
  $Res call({
    int designsCreated,
    int mechanicsGenerated,
    int narrativesWritten,
    double creativityScore,
    List<String> popularGenres,
  });
}

/// @nodoc
class _$CreativeMetricsCopyWithImpl<$Res, $Val extends CreativeMetrics>
    implements $CreativeMetricsCopyWith<$Res> {
  _$CreativeMetricsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CreativeMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? designsCreated = null,
    Object? mechanicsGenerated = null,
    Object? narrativesWritten = null,
    Object? creativityScore = null,
    Object? popularGenres = null,
  }) {
    return _then(
      _value.copyWith(
            designsCreated: null == designsCreated
                ? _value.designsCreated
                : designsCreated // ignore: cast_nullable_to_non_nullable
                      as int,
            mechanicsGenerated: null == mechanicsGenerated
                ? _value.mechanicsGenerated
                : mechanicsGenerated // ignore: cast_nullable_to_non_nullable
                      as int,
            narrativesWritten: null == narrativesWritten
                ? _value.narrativesWritten
                : narrativesWritten // ignore: cast_nullable_to_non_nullable
                      as int,
            creativityScore: null == creativityScore
                ? _value.creativityScore
                : creativityScore // ignore: cast_nullable_to_non_nullable
                      as double,
            popularGenres: null == popularGenres
                ? _value.popularGenres
                : popularGenres // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$CreativeMetricsImplCopyWith<$Res>
    implements $CreativeMetricsCopyWith<$Res> {
  factory _$$CreativeMetricsImplCopyWith(
    _$CreativeMetricsImpl value,
    $Res Function(_$CreativeMetricsImpl) then,
  ) = __$$CreativeMetricsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int designsCreated,
    int mechanicsGenerated,
    int narrativesWritten,
    double creativityScore,
    List<String> popularGenres,
  });
}

/// @nodoc
class __$$CreativeMetricsImplCopyWithImpl<$Res>
    extends _$CreativeMetricsCopyWithImpl<$Res, _$CreativeMetricsImpl>
    implements _$$CreativeMetricsImplCopyWith<$Res> {
  __$$CreativeMetricsImplCopyWithImpl(
    _$CreativeMetricsImpl _value,
    $Res Function(_$CreativeMetricsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of CreativeMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? designsCreated = null,
    Object? mechanicsGenerated = null,
    Object? narrativesWritten = null,
    Object? creativityScore = null,
    Object? popularGenres = null,
  }) {
    return _then(
      _$CreativeMetricsImpl(
        designsCreated: null == designsCreated
            ? _value.designsCreated
            : designsCreated // ignore: cast_nullable_to_non_nullable
                  as int,
        mechanicsGenerated: null == mechanicsGenerated
            ? _value.mechanicsGenerated
            : mechanicsGenerated // ignore: cast_nullable_to_non_nullable
                  as int,
        narrativesWritten: null == narrativesWritten
            ? _value.narrativesWritten
            : narrativesWritten // ignore: cast_nullable_to_non_nullable
                  as int,
        creativityScore: null == creativityScore
            ? _value.creativityScore
            : creativityScore // ignore: cast_nullable_to_non_nullable
                  as double,
        popularGenres: null == popularGenres
            ? _value._popularGenres
            : popularGenres // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CreativeMetricsImpl implements _CreativeMetrics {
  const _$CreativeMetricsImpl({
    required this.designsCreated,
    required this.mechanicsGenerated,
    required this.narrativesWritten,
    required this.creativityScore,
    required final List<String> popularGenres,
  }) : _popularGenres = popularGenres;

  factory _$CreativeMetricsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreativeMetricsImplFromJson(json);

  @override
  final int designsCreated;
  @override
  final int mechanicsGenerated;
  @override
  final int narrativesWritten;
  @override
  final double creativityScore;
  final List<String> _popularGenres;
  @override
  List<String> get popularGenres {
    if (_popularGenres is EqualUnmodifiableListView) return _popularGenres;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_popularGenres);
  }

  @override
  String toString() {
    return 'CreativeMetrics(designsCreated: $designsCreated, mechanicsGenerated: $mechanicsGenerated, narrativesWritten: $narrativesWritten, creativityScore: $creativityScore, popularGenres: $popularGenres)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreativeMetricsImpl &&
            (identical(other.designsCreated, designsCreated) ||
                other.designsCreated == designsCreated) &&
            (identical(other.mechanicsGenerated, mechanicsGenerated) ||
                other.mechanicsGenerated == mechanicsGenerated) &&
            (identical(other.narrativesWritten, narrativesWritten) ||
                other.narrativesWritten == narrativesWritten) &&
            (identical(other.creativityScore, creativityScore) ||
                other.creativityScore == creativityScore) &&
            const DeepCollectionEquality().equals(
              other._popularGenres,
              _popularGenres,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    designsCreated,
    mechanicsGenerated,
    narrativesWritten,
    creativityScore,
    const DeepCollectionEquality().hash(_popularGenres),
  );

  /// Create a copy of CreativeMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreativeMetricsImplCopyWith<_$CreativeMetricsImpl> get copyWith =>
      __$$CreativeMetricsImplCopyWithImpl<_$CreativeMetricsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$CreativeMetricsImplToJson(this);
  }
}

abstract class _CreativeMetrics implements CreativeMetrics {
  const factory _CreativeMetrics({
    required final int designsCreated,
    required final int mechanicsGenerated,
    required final int narrativesWritten,
    required final double creativityScore,
    required final List<String> popularGenres,
  }) = _$CreativeMetricsImpl;

  factory _CreativeMetrics.fromJson(Map<String, dynamic> json) =
      _$CreativeMetricsImpl.fromJson;

  @override
  int get designsCreated;
  @override
  int get mechanicsGenerated;
  @override
  int get narrativesWritten;
  @override
  double get creativityScore;
  @override
  List<String> get popularGenres;

  /// Create a copy of CreativeMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreativeMetricsImplCopyWith<_$CreativeMetricsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AssetMetrics _$AssetMetricsFromJson(Map<String, dynamic> json) {
  return _AssetMetrics.fromJson(json);
}

/// @nodoc
mixin _$AssetMetrics {
  int get assetsGenerated => throw _privateConstructorUsedError;
  Map<AssetType, int> get assetsByType => throw _privateConstructorUsedError;
  double get averageGenerationTime => throw _privateConstructorUsedError;
  double get qualityScore => throw _privateConstructorUsedError;
  List<String> get topEngines => throw _privateConstructorUsedError;

  /// Serializes this AssetMetrics to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AssetMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AssetMetricsCopyWith<AssetMetrics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetMetricsCopyWith<$Res> {
  factory $AssetMetricsCopyWith(
    AssetMetrics value,
    $Res Function(AssetMetrics) then,
  ) = _$AssetMetricsCopyWithImpl<$Res, AssetMetrics>;
  @useResult
  $Res call({
    int assetsGenerated,
    Map<AssetType, int> assetsByType,
    double averageGenerationTime,
    double qualityScore,
    List<String> topEngines,
  });
}

/// @nodoc
class _$AssetMetricsCopyWithImpl<$Res, $Val extends AssetMetrics>
    implements $AssetMetricsCopyWith<$Res> {
  _$AssetMetricsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AssetMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetsGenerated = null,
    Object? assetsByType = null,
    Object? averageGenerationTime = null,
    Object? qualityScore = null,
    Object? topEngines = null,
  }) {
    return _then(
      _value.copyWith(
            assetsGenerated: null == assetsGenerated
                ? _value.assetsGenerated
                : assetsGenerated // ignore: cast_nullable_to_non_nullable
                      as int,
            assetsByType: null == assetsByType
                ? _value.assetsByType
                : assetsByType // ignore: cast_nullable_to_non_nullable
                      as Map<AssetType, int>,
            averageGenerationTime: null == averageGenerationTime
                ? _value.averageGenerationTime
                : averageGenerationTime // ignore: cast_nullable_to_non_nullable
                      as double,
            qualityScore: null == qualityScore
                ? _value.qualityScore
                : qualityScore // ignore: cast_nullable_to_non_nullable
                      as double,
            topEngines: null == topEngines
                ? _value.topEngines
                : topEngines // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AssetMetricsImplCopyWith<$Res>
    implements $AssetMetricsCopyWith<$Res> {
  factory _$$AssetMetricsImplCopyWith(
    _$AssetMetricsImpl value,
    $Res Function(_$AssetMetricsImpl) then,
  ) = __$$AssetMetricsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int assetsGenerated,
    Map<AssetType, int> assetsByType,
    double averageGenerationTime,
    double qualityScore,
    List<String> topEngines,
  });
}

/// @nodoc
class __$$AssetMetricsImplCopyWithImpl<$Res>
    extends _$AssetMetricsCopyWithImpl<$Res, _$AssetMetricsImpl>
    implements _$$AssetMetricsImplCopyWith<$Res> {
  __$$AssetMetricsImplCopyWithImpl(
    _$AssetMetricsImpl _value,
    $Res Function(_$AssetMetricsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AssetMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetsGenerated = null,
    Object? assetsByType = null,
    Object? averageGenerationTime = null,
    Object? qualityScore = null,
    Object? topEngines = null,
  }) {
    return _then(
      _$AssetMetricsImpl(
        assetsGenerated: null == assetsGenerated
            ? _value.assetsGenerated
            : assetsGenerated // ignore: cast_nullable_to_non_nullable
                  as int,
        assetsByType: null == assetsByType
            ? _value._assetsByType
            : assetsByType // ignore: cast_nullable_to_non_nullable
                  as Map<AssetType, int>,
        averageGenerationTime: null == averageGenerationTime
            ? _value.averageGenerationTime
            : averageGenerationTime // ignore: cast_nullable_to_non_nullable
                  as double,
        qualityScore: null == qualityScore
            ? _value.qualityScore
            : qualityScore // ignore: cast_nullable_to_non_nullable
                  as double,
        topEngines: null == topEngines
            ? _value._topEngines
            : topEngines // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AssetMetricsImpl implements _AssetMetrics {
  const _$AssetMetricsImpl({
    required this.assetsGenerated,
    required final Map<AssetType, int> assetsByType,
    required this.averageGenerationTime,
    required this.qualityScore,
    required final List<String> topEngines,
  }) : _assetsByType = assetsByType,
       _topEngines = topEngines;

  factory _$AssetMetricsImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssetMetricsImplFromJson(json);

  @override
  final int assetsGenerated;
  final Map<AssetType, int> _assetsByType;
  @override
  Map<AssetType, int> get assetsByType {
    if (_assetsByType is EqualUnmodifiableMapView) return _assetsByType;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_assetsByType);
  }

  @override
  final double averageGenerationTime;
  @override
  final double qualityScore;
  final List<String> _topEngines;
  @override
  List<String> get topEngines {
    if (_topEngines is EqualUnmodifiableListView) return _topEngines;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topEngines);
  }

  @override
  String toString() {
    return 'AssetMetrics(assetsGenerated: $assetsGenerated, assetsByType: $assetsByType, averageGenerationTime: $averageGenerationTime, qualityScore: $qualityScore, topEngines: $topEngines)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssetMetricsImpl &&
            (identical(other.assetsGenerated, assetsGenerated) ||
                other.assetsGenerated == assetsGenerated) &&
            const DeepCollectionEquality().equals(
              other._assetsByType,
              _assetsByType,
            ) &&
            (identical(other.averageGenerationTime, averageGenerationTime) ||
                other.averageGenerationTime == averageGenerationTime) &&
            (identical(other.qualityScore, qualityScore) ||
                other.qualityScore == qualityScore) &&
            const DeepCollectionEquality().equals(
              other._topEngines,
              _topEngines,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    assetsGenerated,
    const DeepCollectionEquality().hash(_assetsByType),
    averageGenerationTime,
    qualityScore,
    const DeepCollectionEquality().hash(_topEngines),
  );

  /// Create a copy of AssetMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AssetMetricsImplCopyWith<_$AssetMetricsImpl> get copyWith =>
      __$$AssetMetricsImplCopyWithImpl<_$AssetMetricsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssetMetricsImplToJson(this);
  }
}

abstract class _AssetMetrics implements AssetMetrics {
  const factory _AssetMetrics({
    required final int assetsGenerated,
    required final Map<AssetType, int> assetsByType,
    required final double averageGenerationTime,
    required final double qualityScore,
    required final List<String> topEngines,
  }) = _$AssetMetricsImpl;

  factory _AssetMetrics.fromJson(Map<String, dynamic> json) =
      _$AssetMetricsImpl.fromJson;

  @override
  int get assetsGenerated;
  @override
  Map<AssetType, int> get assetsByType;
  @override
  double get averageGenerationTime;
  @override
  double get qualityScore;
  @override
  List<String> get topEngines;

  /// Create a copy of AssetMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AssetMetricsImplCopyWith<_$AssetMetricsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrchestratorMetrics _$OrchestratorMetricsFromJson(Map<String, dynamic> json) {
  return _OrchestratorMetrics.fromJson(json);
}

/// @nodoc
mixin _$OrchestratorMetrics {
  int get workflowsCompleted => throw _privateConstructorUsedError;
  int get totalSteps => throw _privateConstructorUsedError;
  double get successRate => throw _privateConstructorUsedError;
  double get averageWorkflowTime => throw _privateConstructorUsedError;
  List<String> get commonErrors => throw _privateConstructorUsedError;

  /// Serializes this OrchestratorMetrics to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrchestratorMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrchestratorMetricsCopyWith<OrchestratorMetrics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrchestratorMetricsCopyWith<$Res> {
  factory $OrchestratorMetricsCopyWith(
    OrchestratorMetrics value,
    $Res Function(OrchestratorMetrics) then,
  ) = _$OrchestratorMetricsCopyWithImpl<$Res, OrchestratorMetrics>;
  @useResult
  $Res call({
    int workflowsCompleted,
    int totalSteps,
    double successRate,
    double averageWorkflowTime,
    List<String> commonErrors,
  });
}

/// @nodoc
class _$OrchestratorMetricsCopyWithImpl<$Res, $Val extends OrchestratorMetrics>
    implements $OrchestratorMetricsCopyWith<$Res> {
  _$OrchestratorMetricsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrchestratorMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowsCompleted = null,
    Object? totalSteps = null,
    Object? successRate = null,
    Object? averageWorkflowTime = null,
    Object? commonErrors = null,
  }) {
    return _then(
      _value.copyWith(
            workflowsCompleted: null == workflowsCompleted
                ? _value.workflowsCompleted
                : workflowsCompleted // ignore: cast_nullable_to_non_nullable
                      as int,
            totalSteps: null == totalSteps
                ? _value.totalSteps
                : totalSteps // ignore: cast_nullable_to_non_nullable
                      as int,
            successRate: null == successRate
                ? _value.successRate
                : successRate // ignore: cast_nullable_to_non_nullable
                      as double,
            averageWorkflowTime: null == averageWorkflowTime
                ? _value.averageWorkflowTime
                : averageWorkflowTime // ignore: cast_nullable_to_non_nullable
                      as double,
            commonErrors: null == commonErrors
                ? _value.commonErrors
                : commonErrors // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$OrchestratorMetricsImplCopyWith<$Res>
    implements $OrchestratorMetricsCopyWith<$Res> {
  factory _$$OrchestratorMetricsImplCopyWith(
    _$OrchestratorMetricsImpl value,
    $Res Function(_$OrchestratorMetricsImpl) then,
  ) = __$$OrchestratorMetricsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int workflowsCompleted,
    int totalSteps,
    double successRate,
    double averageWorkflowTime,
    List<String> commonErrors,
  });
}

/// @nodoc
class __$$OrchestratorMetricsImplCopyWithImpl<$Res>
    extends _$OrchestratorMetricsCopyWithImpl<$Res, _$OrchestratorMetricsImpl>
    implements _$$OrchestratorMetricsImplCopyWith<$Res> {
  __$$OrchestratorMetricsImplCopyWithImpl(
    _$OrchestratorMetricsImpl _value,
    $Res Function(_$OrchestratorMetricsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrchestratorMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowsCompleted = null,
    Object? totalSteps = null,
    Object? successRate = null,
    Object? averageWorkflowTime = null,
    Object? commonErrors = null,
  }) {
    return _then(
      _$OrchestratorMetricsImpl(
        workflowsCompleted: null == workflowsCompleted
            ? _value.workflowsCompleted
            : workflowsCompleted // ignore: cast_nullable_to_non_nullable
                  as int,
        totalSteps: null == totalSteps
            ? _value.totalSteps
            : totalSteps // ignore: cast_nullable_to_non_nullable
                  as int,
        successRate: null == successRate
            ? _value.successRate
            : successRate // ignore: cast_nullable_to_non_nullable
                  as double,
        averageWorkflowTime: null == averageWorkflowTime
            ? _value.averageWorkflowTime
            : averageWorkflowTime // ignore: cast_nullable_to_non_nullable
                  as double,
        commonErrors: null == commonErrors
            ? _value._commonErrors
            : commonErrors // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrchestratorMetricsImpl implements _OrchestratorMetrics {
  const _$OrchestratorMetricsImpl({
    required this.workflowsCompleted,
    required this.totalSteps,
    required this.successRate,
    required this.averageWorkflowTime,
    required final List<String> commonErrors,
  }) : _commonErrors = commonErrors;

  factory _$OrchestratorMetricsImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrchestratorMetricsImplFromJson(json);

  @override
  final int workflowsCompleted;
  @override
  final int totalSteps;
  @override
  final double successRate;
  @override
  final double averageWorkflowTime;
  final List<String> _commonErrors;
  @override
  List<String> get commonErrors {
    if (_commonErrors is EqualUnmodifiableListView) return _commonErrors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_commonErrors);
  }

  @override
  String toString() {
    return 'OrchestratorMetrics(workflowsCompleted: $workflowsCompleted, totalSteps: $totalSteps, successRate: $successRate, averageWorkflowTime: $averageWorkflowTime, commonErrors: $commonErrors)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrchestratorMetricsImpl &&
            (identical(other.workflowsCompleted, workflowsCompleted) ||
                other.workflowsCompleted == workflowsCompleted) &&
            (identical(other.totalSteps, totalSteps) ||
                other.totalSteps == totalSteps) &&
            (identical(other.successRate, successRate) ||
                other.successRate == successRate) &&
            (identical(other.averageWorkflowTime, averageWorkflowTime) ||
                other.averageWorkflowTime == averageWorkflowTime) &&
            const DeepCollectionEquality().equals(
              other._commonErrors,
              _commonErrors,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    workflowsCompleted,
    totalSteps,
    successRate,
    averageWorkflowTime,
    const DeepCollectionEquality().hash(_commonErrors),
  );

  /// Create a copy of OrchestratorMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrchestratorMetricsImplCopyWith<_$OrchestratorMetricsImpl> get copyWith =>
      __$$OrchestratorMetricsImplCopyWithImpl<_$OrchestratorMetricsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$OrchestratorMetricsImplToJson(this);
  }
}

abstract class _OrchestratorMetrics implements OrchestratorMetrics {
  const factory _OrchestratorMetrics({
    required final int workflowsCompleted,
    required final int totalSteps,
    required final double successRate,
    required final double averageWorkflowTime,
    required final List<String> commonErrors,
  }) = _$OrchestratorMetricsImpl;

  factory _OrchestratorMetrics.fromJson(Map<String, dynamic> json) =
      _$OrchestratorMetricsImpl.fromJson;

  @override
  int get workflowsCompleted;
  @override
  int get totalSteps;
  @override
  double get successRate;
  @override
  double get averageWorkflowTime;
  @override
  List<String> get commonErrors;

  /// Create a copy of OrchestratorMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrchestratorMetricsImplCopyWith<_$OrchestratorMetricsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ResearchResult _$ResearchResultFromJson(Map<String, dynamic> json) {
  return _ResearchResult.fromJson(json);
}

/// @nodoc
mixin _$ResearchResult {
  String get id => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String get source => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  double get relevance => throw _privateConstructorUsedError;

  /// Serializes this ResearchResult to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ResearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResearchResultCopyWith<ResearchResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResearchResultCopyWith<$Res> {
  factory $ResearchResultCopyWith(
    ResearchResult value,
    $Res Function(ResearchResult) then,
  ) = _$ResearchResultCopyWithImpl<$Res, ResearchResult>;
  @useResult
  $Res call({
    String id,
    String title,
    String description,
    String source,
    DateTime date,
    List<String> tags,
    String url,
    double relevance,
  });
}

/// @nodoc
class _$ResearchResultCopyWithImpl<$Res, $Val extends ResearchResult>
    implements $ResearchResultCopyWith<$Res> {
  _$ResearchResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? description = null,
    Object? source = null,
    Object? date = null,
    Object? tags = null,
    Object? url = null,
    Object? relevance = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            source: null == source
                ? _value.source
                : source // ignore: cast_nullable_to_non_nullable
                      as String,
            date: null == date
                ? _value.date
                : date // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            tags: null == tags
                ? _value.tags
                : tags // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            url: null == url
                ? _value.url
                : url // ignore: cast_nullable_to_non_nullable
                      as String,
            relevance: null == relevance
                ? _value.relevance
                : relevance // ignore: cast_nullable_to_non_nullable
                      as double,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ResearchResultImplCopyWith<$Res>
    implements $ResearchResultCopyWith<$Res> {
  factory _$$ResearchResultImplCopyWith(
    _$ResearchResultImpl value,
    $Res Function(_$ResearchResultImpl) then,
  ) = __$$ResearchResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String title,
    String description,
    String source,
    DateTime date,
    List<String> tags,
    String url,
    double relevance,
  });
}

/// @nodoc
class __$$ResearchResultImplCopyWithImpl<$Res>
    extends _$ResearchResultCopyWithImpl<$Res, _$ResearchResultImpl>
    implements _$$ResearchResultImplCopyWith<$Res> {
  __$$ResearchResultImplCopyWithImpl(
    _$ResearchResultImpl _value,
    $Res Function(_$ResearchResultImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ResearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? description = null,
    Object? source = null,
    Object? date = null,
    Object? tags = null,
    Object? url = null,
    Object? relevance = null,
  }) {
    return _then(
      _$ResearchResultImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        source: null == source
            ? _value.source
            : source // ignore: cast_nullable_to_non_nullable
                  as String,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        tags: null == tags
            ? _value._tags
            : tags // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        url: null == url
            ? _value.url
            : url // ignore: cast_nullable_to_non_nullable
                  as String,
        relevance: null == relevance
            ? _value.relevance
            : relevance // ignore: cast_nullable_to_non_nullable
                  as double,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ResearchResultImpl implements _ResearchResult {
  const _$ResearchResultImpl({
    required this.id,
    required this.title,
    required this.description,
    required this.source,
    required this.date,
    required final List<String> tags,
    required this.url,
    required this.relevance,
  }) : _tags = tags;

  factory _$ResearchResultImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResearchResultImplFromJson(json);

  @override
  final String id;
  @override
  final String title;
  @override
  final String description;
  @override
  final String source;
  @override
  final DateTime date;
  final List<String> _tags;
  @override
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final String url;
  @override
  final double relevance;

  @override
  String toString() {
    return 'ResearchResult(id: $id, title: $title, description: $description, source: $source, date: $date, tags: $tags, url: $url, relevance: $relevance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResearchResultImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.date, date) || other.date == date) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.relevance, relevance) ||
                other.relevance == relevance));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    title,
    description,
    source,
    date,
    const DeepCollectionEquality().hash(_tags),
    url,
    relevance,
  );

  /// Create a copy of ResearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResearchResultImplCopyWith<_$ResearchResultImpl> get copyWith =>
      __$$ResearchResultImplCopyWithImpl<_$ResearchResultImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ResearchResultImplToJson(this);
  }
}

abstract class _ResearchResult implements ResearchResult {
  const factory _ResearchResult({
    required final String id,
    required final String title,
    required final String description,
    required final String source,
    required final DateTime date,
    required final List<String> tags,
    required final String url,
    required final double relevance,
  }) = _$ResearchResultImpl;

  factory _ResearchResult.fromJson(Map<String, dynamic> json) =
      _$ResearchResultImpl.fromJson;

  @override
  String get id;
  @override
  String get title;
  @override
  String get description;
  @override
  String get source;
  @override
  DateTime get date;
  @override
  List<String> get tags;
  @override
  String get url;
  @override
  double get relevance;

  /// Create a copy of ResearchResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResearchResultImplCopyWith<_$ResearchResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GeneratedAsset _$GeneratedAssetFromJson(Map<String, dynamic> json) {
  return _GeneratedAsset.fromJson(json);
}

/// @nodoc
mixin _$GeneratedAsset {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  AssetType get type => throw _privateConstructorUsedError;
  String get fileUrl => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  String get engine => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;
  double get quality => throw _privateConstructorUsedError;

  /// Serializes this GeneratedAsset to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GeneratedAsset
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GeneratedAssetCopyWith<GeneratedAsset> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratedAssetCopyWith<$Res> {
  factory $GeneratedAssetCopyWith(
    GeneratedAsset value,
    $Res Function(GeneratedAsset) then,
  ) = _$GeneratedAssetCopyWithImpl<$Res, GeneratedAsset>;
  @useResult
  $Res call({
    String id,
    String name,
    AssetType type,
    String fileUrl,
    DateTime createdAt,
    String engine,
    Map<String, dynamic> metadata,
    double quality,
  });
}

/// @nodoc
class _$GeneratedAssetCopyWithImpl<$Res, $Val extends GeneratedAsset>
    implements $GeneratedAssetCopyWith<$Res> {
  _$GeneratedAssetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GeneratedAsset
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? type = null,
    Object? fileUrl = null,
    Object? createdAt = null,
    Object? engine = null,
    Object? metadata = null,
    Object? quality = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as AssetType,
            fileUrl: null == fileUrl
                ? _value.fileUrl
                : fileUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            createdAt: null == createdAt
                ? _value.createdAt
                : createdAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            engine: null == engine
                ? _value.engine
                : engine // ignore: cast_nullable_to_non_nullable
                      as String,
            metadata: null == metadata
                ? _value.metadata
                : metadata // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            quality: null == quality
                ? _value.quality
                : quality // ignore: cast_nullable_to_non_nullable
                      as double,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$GeneratedAssetImplCopyWith<$Res>
    implements $GeneratedAssetCopyWith<$Res> {
  factory _$$GeneratedAssetImplCopyWith(
    _$GeneratedAssetImpl value,
    $Res Function(_$GeneratedAssetImpl) then,
  ) = __$$GeneratedAssetImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    AssetType type,
    String fileUrl,
    DateTime createdAt,
    String engine,
    Map<String, dynamic> metadata,
    double quality,
  });
}

/// @nodoc
class __$$GeneratedAssetImplCopyWithImpl<$Res>
    extends _$GeneratedAssetCopyWithImpl<$Res, _$GeneratedAssetImpl>
    implements _$$GeneratedAssetImplCopyWith<$Res> {
  __$$GeneratedAssetImplCopyWithImpl(
    _$GeneratedAssetImpl _value,
    $Res Function(_$GeneratedAssetImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of GeneratedAsset
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? type = null,
    Object? fileUrl = null,
    Object? createdAt = null,
    Object? engine = null,
    Object? metadata = null,
    Object? quality = null,
  }) {
    return _then(
      _$GeneratedAssetImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as AssetType,
        fileUrl: null == fileUrl
            ? _value.fileUrl
            : fileUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        createdAt: null == createdAt
            ? _value.createdAt
            : createdAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        engine: null == engine
            ? _value.engine
            : engine // ignore: cast_nullable_to_non_nullable
                  as String,
        metadata: null == metadata
            ? _value._metadata
            : metadata // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        quality: null == quality
            ? _value.quality
            : quality // ignore: cast_nullable_to_non_nullable
                  as double,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$GeneratedAssetImpl implements _GeneratedAsset {
  const _$GeneratedAssetImpl({
    required this.id,
    required this.name,
    required this.type,
    required this.fileUrl,
    required this.createdAt,
    required this.engine,
    required final Map<String, dynamic> metadata,
    required this.quality,
  }) : _metadata = metadata;

  factory _$GeneratedAssetImpl.fromJson(Map<String, dynamic> json) =>
      _$$GeneratedAssetImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final AssetType type;
  @override
  final String fileUrl;
  @override
  final DateTime createdAt;
  @override
  final String engine;
  final Map<String, dynamic> _metadata;
  @override
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  final double quality;

  @override
  String toString() {
    return 'GeneratedAsset(id: $id, name: $name, type: $type, fileUrl: $fileUrl, createdAt: $createdAt, engine: $engine, metadata: $metadata, quality: $quality)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GeneratedAssetImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.engine, engine) || other.engine == engine) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.quality, quality) || other.quality == quality));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    type,
    fileUrl,
    createdAt,
    engine,
    const DeepCollectionEquality().hash(_metadata),
    quality,
  );

  /// Create a copy of GeneratedAsset
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GeneratedAssetImplCopyWith<_$GeneratedAssetImpl> get copyWith =>
      __$$GeneratedAssetImplCopyWithImpl<_$GeneratedAssetImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$GeneratedAssetImplToJson(this);
  }
}

abstract class _GeneratedAsset implements GeneratedAsset {
  const factory _GeneratedAsset({
    required final String id,
    required final String name,
    required final AssetType type,
    required final String fileUrl,
    required final DateTime createdAt,
    required final String engine,
    required final Map<String, dynamic> metadata,
    required final double quality,
  }) = _$GeneratedAssetImpl;

  factory _GeneratedAsset.fromJson(Map<String, dynamic> json) =
      _$GeneratedAssetImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  AssetType get type;
  @override
  String get fileUrl;
  @override
  DateTime get createdAt;
  @override
  String get engine;
  @override
  Map<String, dynamic> get metadata;
  @override
  double get quality;

  /// Create a copy of GeneratedAsset
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GeneratedAssetImplCopyWith<_$GeneratedAssetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ProjectMasterAgent _$ProjectMasterAgentFromJson(Map<String, dynamic> json) {
  return _ProjectMasterAgent.fromJson(json);
}

/// @nodoc
mixin _$ProjectMasterAgent {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  AgentType get type => throw _privateConstructorUsedError;
  AgentStatus get status => throw _privateConstructorUsedError;
  Map<String, dynamic> get capabilities => throw _privateConstructorUsedError;
  List<String> get skills => throw _privateConstructorUsedError;
  Map<String, dynamic> get preferences => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  List<Prototype> get prototypes => throw _privateConstructorUsedError;
  List<PlaytestResult> get playtests => throw _privateConstructorUsedError;
  List<TeamMember> get team => throw _privateConstructorUsedError;
  List<GeneratedAsset> get assets => throw _privateConstructorUsedError;
  List<ProjectDecision> get decisions => throw _privateConstructorUsedError;

  /// Serializes this ProjectMasterAgent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ProjectMasterAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProjectMasterAgentCopyWith<ProjectMasterAgent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProjectMasterAgentCopyWith<$Res> {
  factory $ProjectMasterAgentCopyWith(
    ProjectMasterAgent value,
    $Res Function(ProjectMasterAgent) then,
  ) = _$ProjectMasterAgentCopyWithImpl<$Res, ProjectMasterAgent>;
  @useResult
  $Res call({
    String id,
    String name,
    String description,
    AgentType type,
    AgentStatus status,
    Map<String, dynamic> capabilities,
    List<String> skills,
    Map<String, dynamic> preferences,
    DateTime createdAt,
    DateTime updatedAt,
    List<Prototype> prototypes,
    List<PlaytestResult> playtests,
    List<TeamMember> team,
    List<GeneratedAsset> assets,
    List<ProjectDecision> decisions,
  });
}

/// @nodoc
class _$ProjectMasterAgentCopyWithImpl<$Res, $Val extends ProjectMasterAgent>
    implements $ProjectMasterAgentCopyWith<$Res> {
  _$ProjectMasterAgentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProjectMasterAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? type = null,
    Object? status = null,
    Object? capabilities = null,
    Object? skills = null,
    Object? preferences = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? prototypes = null,
    Object? playtests = null,
    Object? team = null,
    Object? assets = null,
    Object? decisions = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as AgentType,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as AgentStatus,
            capabilities: null == capabilities
                ? _value.capabilities
                : capabilities // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            skills: null == skills
                ? _value.skills
                : skills // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            preferences: null == preferences
                ? _value.preferences
                : preferences // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            createdAt: null == createdAt
                ? _value.createdAt
                : createdAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            updatedAt: null == updatedAt
                ? _value.updatedAt
                : updatedAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            prototypes: null == prototypes
                ? _value.prototypes
                : prototypes // ignore: cast_nullable_to_non_nullable
                      as List<Prototype>,
            playtests: null == playtests
                ? _value.playtests
                : playtests // ignore: cast_nullable_to_non_nullable
                      as List<PlaytestResult>,
            team: null == team
                ? _value.team
                : team // ignore: cast_nullable_to_non_nullable
                      as List<TeamMember>,
            assets: null == assets
                ? _value.assets
                : assets // ignore: cast_nullable_to_non_nullable
                      as List<GeneratedAsset>,
            decisions: null == decisions
                ? _value.decisions
                : decisions // ignore: cast_nullable_to_non_nullable
                      as List<ProjectDecision>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ProjectMasterAgentImplCopyWith<$Res>
    implements $ProjectMasterAgentCopyWith<$Res> {
  factory _$$ProjectMasterAgentImplCopyWith(
    _$ProjectMasterAgentImpl value,
    $Res Function(_$ProjectMasterAgentImpl) then,
  ) = __$$ProjectMasterAgentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    String description,
    AgentType type,
    AgentStatus status,
    Map<String, dynamic> capabilities,
    List<String> skills,
    Map<String, dynamic> preferences,
    DateTime createdAt,
    DateTime updatedAt,
    List<Prototype> prototypes,
    List<PlaytestResult> playtests,
    List<TeamMember> team,
    List<GeneratedAsset> assets,
    List<ProjectDecision> decisions,
  });
}

/// @nodoc
class __$$ProjectMasterAgentImplCopyWithImpl<$Res>
    extends _$ProjectMasterAgentCopyWithImpl<$Res, _$ProjectMasterAgentImpl>
    implements _$$ProjectMasterAgentImplCopyWith<$Res> {
  __$$ProjectMasterAgentImplCopyWithImpl(
    _$ProjectMasterAgentImpl _value,
    $Res Function(_$ProjectMasterAgentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ProjectMasterAgent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? type = null,
    Object? status = null,
    Object? capabilities = null,
    Object? skills = null,
    Object? preferences = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? prototypes = null,
    Object? playtests = null,
    Object? team = null,
    Object? assets = null,
    Object? decisions = null,
  }) {
    return _then(
      _$ProjectMasterAgentImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as AgentType,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as AgentStatus,
        capabilities: null == capabilities
            ? _value._capabilities
            : capabilities // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        skills: null == skills
            ? _value._skills
            : skills // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        preferences: null == preferences
            ? _value._preferences
            : preferences // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        createdAt: null == createdAt
            ? _value.createdAt
            : createdAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        updatedAt: null == updatedAt
            ? _value.updatedAt
            : updatedAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        prototypes: null == prototypes
            ? _value._prototypes
            : prototypes // ignore: cast_nullable_to_non_nullable
                  as List<Prototype>,
        playtests: null == playtests
            ? _value._playtests
            : playtests // ignore: cast_nullable_to_non_nullable
                  as List<PlaytestResult>,
        team: null == team
            ? _value._team
            : team // ignore: cast_nullable_to_non_nullable
                  as List<TeamMember>,
        assets: null == assets
            ? _value._assets
            : assets // ignore: cast_nullable_to_non_nullable
                  as List<GeneratedAsset>,
        decisions: null == decisions
            ? _value._decisions
            : decisions // ignore: cast_nullable_to_non_nullable
                  as List<ProjectDecision>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ProjectMasterAgentImpl implements _ProjectMasterAgent {
  const _$ProjectMasterAgentImpl({
    required this.id,
    required this.name,
    required this.description,
    required this.type,
    required this.status,
    required final Map<String, dynamic> capabilities,
    required final List<String> skills,
    required final Map<String, dynamic> preferences,
    required this.createdAt,
    required this.updatedAt,
    required final List<Prototype> prototypes,
    required final List<PlaytestResult> playtests,
    required final List<TeamMember> team,
    required final List<GeneratedAsset> assets,
    required final List<ProjectDecision> decisions,
  }) : _capabilities = capabilities,
       _skills = skills,
       _preferences = preferences,
       _prototypes = prototypes,
       _playtests = playtests,
       _team = team,
       _assets = assets,
       _decisions = decisions;

  factory _$ProjectMasterAgentImpl.fromJson(Map<String, dynamic> json) =>
      _$$ProjectMasterAgentImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String description;
  @override
  final AgentType type;
  @override
  final AgentStatus status;
  final Map<String, dynamic> _capabilities;
  @override
  Map<String, dynamic> get capabilities {
    if (_capabilities is EqualUnmodifiableMapView) return _capabilities;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_capabilities);
  }

  final List<String> _skills;
  @override
  List<String> get skills {
    if (_skills is EqualUnmodifiableListView) return _skills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_skills);
  }

  final Map<String, dynamic> _preferences;
  @override
  Map<String, dynamic> get preferences {
    if (_preferences is EqualUnmodifiableMapView) return _preferences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_preferences);
  }

  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  final List<Prototype> _prototypes;
  @override
  List<Prototype> get prototypes {
    if (_prototypes is EqualUnmodifiableListView) return _prototypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_prototypes);
  }

  final List<PlaytestResult> _playtests;
  @override
  List<PlaytestResult> get playtests {
    if (_playtests is EqualUnmodifiableListView) return _playtests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_playtests);
  }

  final List<TeamMember> _team;
  @override
  List<TeamMember> get team {
    if (_team is EqualUnmodifiableListView) return _team;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_team);
  }

  final List<GeneratedAsset> _assets;
  @override
  List<GeneratedAsset> get assets {
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_assets);
  }

  final List<ProjectDecision> _decisions;
  @override
  List<ProjectDecision> get decisions {
    if (_decisions is EqualUnmodifiableListView) return _decisions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_decisions);
  }

  @override
  String toString() {
    return 'ProjectMasterAgent(id: $id, name: $name, description: $description, type: $type, status: $status, capabilities: $capabilities, skills: $skills, preferences: $preferences, createdAt: $createdAt, updatedAt: $updatedAt, prototypes: $prototypes, playtests: $playtests, team: $team, assets: $assets, decisions: $decisions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProjectMasterAgentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(
              other._capabilities,
              _capabilities,
            ) &&
            const DeepCollectionEquality().equals(other._skills, _skills) &&
            const DeepCollectionEquality().equals(
              other._preferences,
              _preferences,
            ) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            const DeepCollectionEquality().equals(
              other._prototypes,
              _prototypes,
            ) &&
            const DeepCollectionEquality().equals(
              other._playtests,
              _playtests,
            ) &&
            const DeepCollectionEquality().equals(other._team, _team) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality().equals(
              other._decisions,
              _decisions,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    description,
    type,
    status,
    const DeepCollectionEquality().hash(_capabilities),
    const DeepCollectionEquality().hash(_skills),
    const DeepCollectionEquality().hash(_preferences),
    createdAt,
    updatedAt,
    const DeepCollectionEquality().hash(_prototypes),
    const DeepCollectionEquality().hash(_playtests),
    const DeepCollectionEquality().hash(_team),
    const DeepCollectionEquality().hash(_assets),
    const DeepCollectionEquality().hash(_decisions),
  );

  /// Create a copy of ProjectMasterAgent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProjectMasterAgentImplCopyWith<_$ProjectMasterAgentImpl> get copyWith =>
      __$$ProjectMasterAgentImplCopyWithImpl<_$ProjectMasterAgentImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ProjectMasterAgentImplToJson(this);
  }
}

abstract class _ProjectMasterAgent implements ProjectMasterAgent {
  const factory _ProjectMasterAgent({
    required final String id,
    required final String name,
    required final String description,
    required final AgentType type,
    required final AgentStatus status,
    required final Map<String, dynamic> capabilities,
    required final List<String> skills,
    required final Map<String, dynamic> preferences,
    required final DateTime createdAt,
    required final DateTime updatedAt,
    required final List<Prototype> prototypes,
    required final List<PlaytestResult> playtests,
    required final List<TeamMember> team,
    required final List<GeneratedAsset> assets,
    required final List<ProjectDecision> decisions,
  }) = _$ProjectMasterAgentImpl;

  factory _ProjectMasterAgent.fromJson(Map<String, dynamic> json) =
      _$ProjectMasterAgentImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get description;
  @override
  AgentType get type;
  @override
  AgentStatus get status;
  @override
  Map<String, dynamic> get capabilities;
  @override
  List<String> get skills;
  @override
  Map<String, dynamic> get preferences;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  List<Prototype> get prototypes;
  @override
  List<PlaytestResult> get playtests;
  @override
  List<TeamMember> get team;
  @override
  List<GeneratedAsset> get assets;
  @override
  List<ProjectDecision> get decisions;

  /// Create a copy of ProjectMasterAgent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProjectMasterAgentImplCopyWith<_$ProjectMasterAgentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Prototype _$PrototypeFromJson(Map<String, dynamic> json) {
  return _Prototype.fromJson(json);
}

/// @nodoc
mixin _$Prototype {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  String get version => throw _privateConstructorUsedError;
  List<String> get features => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  String get fileUrl => throw _privateConstructorUsedError;

  /// Serializes this Prototype to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Prototype
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PrototypeCopyWith<Prototype> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PrototypeCopyWith<$Res> {
  factory $PrototypeCopyWith(Prototype value, $Res Function(Prototype) then) =
      _$PrototypeCopyWithImpl<$Res, Prototype>;
  @useResult
  $Res call({
    String id,
    String name,
    String description,
    DateTime createdAt,
    String version,
    List<String> features,
    String status,
    String fileUrl,
  });
}

/// @nodoc
class _$PrototypeCopyWithImpl<$Res, $Val extends Prototype>
    implements $PrototypeCopyWith<$Res> {
  _$PrototypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Prototype
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? createdAt = null,
    Object? version = null,
    Object? features = null,
    Object? status = null,
    Object? fileUrl = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            createdAt: null == createdAt
                ? _value.createdAt
                : createdAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            version: null == version
                ? _value.version
                : version // ignore: cast_nullable_to_non_nullable
                      as String,
            features: null == features
                ? _value.features
                : features // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as String,
            fileUrl: null == fileUrl
                ? _value.fileUrl
                : fileUrl // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$PrototypeImplCopyWith<$Res>
    implements $PrototypeCopyWith<$Res> {
  factory _$$PrototypeImplCopyWith(
    _$PrototypeImpl value,
    $Res Function(_$PrototypeImpl) then,
  ) = __$$PrototypeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    String description,
    DateTime createdAt,
    String version,
    List<String> features,
    String status,
    String fileUrl,
  });
}

/// @nodoc
class __$$PrototypeImplCopyWithImpl<$Res>
    extends _$PrototypeCopyWithImpl<$Res, _$PrototypeImpl>
    implements _$$PrototypeImplCopyWith<$Res> {
  __$$PrototypeImplCopyWithImpl(
    _$PrototypeImpl _value,
    $Res Function(_$PrototypeImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Prototype
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? createdAt = null,
    Object? version = null,
    Object? features = null,
    Object? status = null,
    Object? fileUrl = null,
  }) {
    return _then(
      _$PrototypeImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        createdAt: null == createdAt
            ? _value.createdAt
            : createdAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        version: null == version
            ? _value.version
            : version // ignore: cast_nullable_to_non_nullable
                  as String,
        features: null == features
            ? _value._features
            : features // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as String,
        fileUrl: null == fileUrl
            ? _value.fileUrl
            : fileUrl // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$PrototypeImpl implements _Prototype {
  const _$PrototypeImpl({
    required this.id,
    required this.name,
    required this.description,
    required this.createdAt,
    required this.version,
    required final List<String> features,
    required this.status,
    required this.fileUrl,
  }) : _features = features;

  factory _$PrototypeImpl.fromJson(Map<String, dynamic> json) =>
      _$$PrototypeImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String description;
  @override
  final DateTime createdAt;
  @override
  final String version;
  final List<String> _features;
  @override
  List<String> get features {
    if (_features is EqualUnmodifiableListView) return _features;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_features);
  }

  @override
  final String status;
  @override
  final String fileUrl;

  @override
  String toString() {
    return 'Prototype(id: $id, name: $name, description: $description, createdAt: $createdAt, version: $version, features: $features, status: $status, fileUrl: $fileUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PrototypeImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.version, version) || other.version == version) &&
            const DeepCollectionEquality().equals(other._features, _features) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    description,
    createdAt,
    version,
    const DeepCollectionEquality().hash(_features),
    status,
    fileUrl,
  );

  /// Create a copy of Prototype
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PrototypeImplCopyWith<_$PrototypeImpl> get copyWith =>
      __$$PrototypeImplCopyWithImpl<_$PrototypeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PrototypeImplToJson(this);
  }
}

abstract class _Prototype implements Prototype {
  const factory _Prototype({
    required final String id,
    required final String name,
    required final String description,
    required final DateTime createdAt,
    required final String version,
    required final List<String> features,
    required final String status,
    required final String fileUrl,
  }) = _$PrototypeImpl;

  factory _Prototype.fromJson(Map<String, dynamic> json) =
      _$PrototypeImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get description;
  @override
  DateTime get createdAt;
  @override
  String get version;
  @override
  List<String> get features;
  @override
  String get status;
  @override
  String get fileUrl;

  /// Create a copy of Prototype
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PrototypeImplCopyWith<_$PrototypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PlaytestResult _$PlaytestResultFromJson(Map<String, dynamic> json) {
  return _PlaytestResult.fromJson(json);
}

/// @nodoc
mixin _$PlaytestResult {
  String get id => throw _privateConstructorUsedError;
  String get prototypeId => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  List<FeedbackEntry> get feedback => throw _privateConstructorUsedError;
  String get summary => throw _privateConstructorUsedError;
  List<String> get issues => throw _privateConstructorUsedError;
  List<String> get improvements => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  double get rating => throw _privateConstructorUsedError;
  Map<String, dynamic> get metrics => throw _privateConstructorUsedError;

  /// Serializes this PlaytestResult to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PlaytestResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PlaytestResultCopyWith<PlaytestResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlaytestResultCopyWith<$Res> {
  factory $PlaytestResultCopyWith(
    PlaytestResult value,
    $Res Function(PlaytestResult) then,
  ) = _$PlaytestResultCopyWithImpl<$Res, PlaytestResult>;
  @useResult
  $Res call({
    String id,
    String prototypeId,
    DateTime date,
    List<FeedbackEntry> feedback,
    String summary,
    List<String> issues,
    List<String> improvements,
    String title,
    String description,
    double rating,
    Map<String, dynamic> metrics,
  });
}

/// @nodoc
class _$PlaytestResultCopyWithImpl<$Res, $Val extends PlaytestResult>
    implements $PlaytestResultCopyWith<$Res> {
  _$PlaytestResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlaytestResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? prototypeId = null,
    Object? date = null,
    Object? feedback = null,
    Object? summary = null,
    Object? issues = null,
    Object? improvements = null,
    Object? title = null,
    Object? description = null,
    Object? rating = null,
    Object? metrics = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            prototypeId: null == prototypeId
                ? _value.prototypeId
                : prototypeId // ignore: cast_nullable_to_non_nullable
                      as String,
            date: null == date
                ? _value.date
                : date // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            feedback: null == feedback
                ? _value.feedback
                : feedback // ignore: cast_nullable_to_non_nullable
                      as List<FeedbackEntry>,
            summary: null == summary
                ? _value.summary
                : summary // ignore: cast_nullable_to_non_nullable
                      as String,
            issues: null == issues
                ? _value.issues
                : issues // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            improvements: null == improvements
                ? _value.improvements
                : improvements // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            rating: null == rating
                ? _value.rating
                : rating // ignore: cast_nullable_to_non_nullable
                      as double,
            metrics: null == metrics
                ? _value.metrics
                : metrics // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$PlaytestResultImplCopyWith<$Res>
    implements $PlaytestResultCopyWith<$Res> {
  factory _$$PlaytestResultImplCopyWith(
    _$PlaytestResultImpl value,
    $Res Function(_$PlaytestResultImpl) then,
  ) = __$$PlaytestResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String prototypeId,
    DateTime date,
    List<FeedbackEntry> feedback,
    String summary,
    List<String> issues,
    List<String> improvements,
    String title,
    String description,
    double rating,
    Map<String, dynamic> metrics,
  });
}

/// @nodoc
class __$$PlaytestResultImplCopyWithImpl<$Res>
    extends _$PlaytestResultCopyWithImpl<$Res, _$PlaytestResultImpl>
    implements _$$PlaytestResultImplCopyWith<$Res> {
  __$$PlaytestResultImplCopyWithImpl(
    _$PlaytestResultImpl _value,
    $Res Function(_$PlaytestResultImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlaytestResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? prototypeId = null,
    Object? date = null,
    Object? feedback = null,
    Object? summary = null,
    Object? issues = null,
    Object? improvements = null,
    Object? title = null,
    Object? description = null,
    Object? rating = null,
    Object? metrics = null,
  }) {
    return _then(
      _$PlaytestResultImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        prototypeId: null == prototypeId
            ? _value.prototypeId
            : prototypeId // ignore: cast_nullable_to_non_nullable
                  as String,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        feedback: null == feedback
            ? _value._feedback
            : feedback // ignore: cast_nullable_to_non_nullable
                  as List<FeedbackEntry>,
        summary: null == summary
            ? _value.summary
            : summary // ignore: cast_nullable_to_non_nullable
                  as String,
        issues: null == issues
            ? _value._issues
            : issues // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        improvements: null == improvements
            ? _value._improvements
            : improvements // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        rating: null == rating
            ? _value.rating
            : rating // ignore: cast_nullable_to_non_nullable
                  as double,
        metrics: null == metrics
            ? _value._metrics
            : metrics // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$PlaytestResultImpl implements _PlaytestResult {
  const _$PlaytestResultImpl({
    required this.id,
    required this.prototypeId,
    required this.date,
    required final List<FeedbackEntry> feedback,
    required this.summary,
    required final List<String> issues,
    required final List<String> improvements,
    required this.title,
    required this.description,
    required this.rating,
    required final Map<String, dynamic> metrics,
  }) : _feedback = feedback,
       _issues = issues,
       _improvements = improvements,
       _metrics = metrics;

  factory _$PlaytestResultImpl.fromJson(Map<String, dynamic> json) =>
      _$$PlaytestResultImplFromJson(json);

  @override
  final String id;
  @override
  final String prototypeId;
  @override
  final DateTime date;
  final List<FeedbackEntry> _feedback;
  @override
  List<FeedbackEntry> get feedback {
    if (_feedback is EqualUnmodifiableListView) return _feedback;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_feedback);
  }

  @override
  final String summary;
  final List<String> _issues;
  @override
  List<String> get issues {
    if (_issues is EqualUnmodifiableListView) return _issues;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_issues);
  }

  final List<String> _improvements;
  @override
  List<String> get improvements {
    if (_improvements is EqualUnmodifiableListView) return _improvements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_improvements);
  }

  @override
  final String title;
  @override
  final String description;
  @override
  final double rating;
  final Map<String, dynamic> _metrics;
  @override
  Map<String, dynamic> get metrics {
    if (_metrics is EqualUnmodifiableMapView) return _metrics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metrics);
  }

  @override
  String toString() {
    return 'PlaytestResult(id: $id, prototypeId: $prototypeId, date: $date, feedback: $feedback, summary: $summary, issues: $issues, improvements: $improvements, title: $title, description: $description, rating: $rating, metrics: $metrics)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlaytestResultImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.prototypeId, prototypeId) ||
                other.prototypeId == prototypeId) &&
            (identical(other.date, date) || other.date == date) &&
            const DeepCollectionEquality().equals(other._feedback, _feedback) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            const DeepCollectionEquality().equals(other._issues, _issues) &&
            const DeepCollectionEquality().equals(
              other._improvements,
              _improvements,
            ) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            const DeepCollectionEquality().equals(other._metrics, _metrics));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    prototypeId,
    date,
    const DeepCollectionEquality().hash(_feedback),
    summary,
    const DeepCollectionEquality().hash(_issues),
    const DeepCollectionEquality().hash(_improvements),
    title,
    description,
    rating,
    const DeepCollectionEquality().hash(_metrics),
  );

  /// Create a copy of PlaytestResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlaytestResultImplCopyWith<_$PlaytestResultImpl> get copyWith =>
      __$$PlaytestResultImplCopyWithImpl<_$PlaytestResultImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$PlaytestResultImplToJson(this);
  }
}

abstract class _PlaytestResult implements PlaytestResult {
  const factory _PlaytestResult({
    required final String id,
    required final String prototypeId,
    required final DateTime date,
    required final List<FeedbackEntry> feedback,
    required final String summary,
    required final List<String> issues,
    required final List<String> improvements,
    required final String title,
    required final String description,
    required final double rating,
    required final Map<String, dynamic> metrics,
  }) = _$PlaytestResultImpl;

  factory _PlaytestResult.fromJson(Map<String, dynamic> json) =
      _$PlaytestResultImpl.fromJson;

  @override
  String get id;
  @override
  String get prototypeId;
  @override
  DateTime get date;
  @override
  List<FeedbackEntry> get feedback;
  @override
  String get summary;
  @override
  List<String> get issues;
  @override
  List<String> get improvements;
  @override
  String get title;
  @override
  String get description;
  @override
  double get rating;
  @override
  Map<String, dynamic> get metrics;

  /// Create a copy of PlaytestResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlaytestResultImplCopyWith<_$PlaytestResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FeedbackEntry _$FeedbackEntryFromJson(Map<String, dynamic> json) {
  return _FeedbackEntry.fromJson(json);
}

/// @nodoc
mixin _$FeedbackEntry {
  String get id => throw _privateConstructorUsedError;
  String get author => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  FeedbackType get type => throw _privateConstructorUsedError;

  /// Serializes this FeedbackEntry to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FeedbackEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FeedbackEntryCopyWith<FeedbackEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeedbackEntryCopyWith<$Res> {
  factory $FeedbackEntryCopyWith(
    FeedbackEntry value,
    $Res Function(FeedbackEntry) then,
  ) = _$FeedbackEntryCopyWithImpl<$Res, FeedbackEntry>;
  @useResult
  $Res call({
    String id,
    String author,
    String content,
    DateTime date,
    FeedbackType type,
  });
}

/// @nodoc
class _$FeedbackEntryCopyWithImpl<$Res, $Val extends FeedbackEntry>
    implements $FeedbackEntryCopyWith<$Res> {
  _$FeedbackEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FeedbackEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? author = null,
    Object? content = null,
    Object? date = null,
    Object? type = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            author: null == author
                ? _value.author
                : author // ignore: cast_nullable_to_non_nullable
                      as String,
            content: null == content
                ? _value.content
                : content // ignore: cast_nullable_to_non_nullable
                      as String,
            date: null == date
                ? _value.date
                : date // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as FeedbackType,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$FeedbackEntryImplCopyWith<$Res>
    implements $FeedbackEntryCopyWith<$Res> {
  factory _$$FeedbackEntryImplCopyWith(
    _$FeedbackEntryImpl value,
    $Res Function(_$FeedbackEntryImpl) then,
  ) = __$$FeedbackEntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String author,
    String content,
    DateTime date,
    FeedbackType type,
  });
}

/// @nodoc
class __$$FeedbackEntryImplCopyWithImpl<$Res>
    extends _$FeedbackEntryCopyWithImpl<$Res, _$FeedbackEntryImpl>
    implements _$$FeedbackEntryImplCopyWith<$Res> {
  __$$FeedbackEntryImplCopyWithImpl(
    _$FeedbackEntryImpl _value,
    $Res Function(_$FeedbackEntryImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of FeedbackEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? author = null,
    Object? content = null,
    Object? date = null,
    Object? type = null,
  }) {
    return _then(
      _$FeedbackEntryImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        author: null == author
            ? _value.author
            : author // ignore: cast_nullable_to_non_nullable
                  as String,
        content: null == content
            ? _value.content
            : content // ignore: cast_nullable_to_non_nullable
                  as String,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as FeedbackType,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$FeedbackEntryImpl implements _FeedbackEntry {
  const _$FeedbackEntryImpl({
    required this.id,
    required this.author,
    required this.content,
    required this.date,
    required this.type,
  });

  factory _$FeedbackEntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$FeedbackEntryImplFromJson(json);

  @override
  final String id;
  @override
  final String author;
  @override
  final String content;
  @override
  final DateTime date;
  @override
  final FeedbackType type;

  @override
  String toString() {
    return 'FeedbackEntry(id: $id, author: $author, content: $content, date: $date, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedbackEntryImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, author, content, date, type);

  /// Create a copy of FeedbackEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedbackEntryImplCopyWith<_$FeedbackEntryImpl> get copyWith =>
      __$$FeedbackEntryImplCopyWithImpl<_$FeedbackEntryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FeedbackEntryImplToJson(this);
  }
}

abstract class _FeedbackEntry implements FeedbackEntry {
  const factory _FeedbackEntry({
    required final String id,
    required final String author,
    required final String content,
    required final DateTime date,
    required final FeedbackType type,
  }) = _$FeedbackEntryImpl;

  factory _FeedbackEntry.fromJson(Map<String, dynamic> json) =
      _$FeedbackEntryImpl.fromJson;

  @override
  String get id;
  @override
  String get author;
  @override
  String get content;
  @override
  DateTime get date;
  @override
  FeedbackType get type;

  /// Create a copy of FeedbackEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedbackEntryImplCopyWith<_$FeedbackEntryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TeamMember _$TeamMemberFromJson(Map<String, dynamic> json) {
  return _TeamMember.fromJson(json);
}

/// @nodoc
mixin _$TeamMember {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get role => throw _privateConstructorUsedError;
  String get contact => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  String get expertise => throw _privateConstructorUsedError;
  List<String> get skills => throw _privateConstructorUsedError;
  double get availability => throw _privateConstructorUsedError;
  Map<String, dynamic> get preferences => throw _privateConstructorUsedError;

  /// Serializes this TeamMember to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TeamMember
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TeamMemberCopyWith<TeamMember> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TeamMemberCopyWith<$Res> {
  factory $TeamMemberCopyWith(
    TeamMember value,
    $Res Function(TeamMember) then,
  ) = _$TeamMemberCopyWithImpl<$Res, TeamMember>;
  @useResult
  $Res call({
    String id,
    String name,
    String role,
    String contact,
    bool isActive,
    String expertise,
    List<String> skills,
    double availability,
    Map<String, dynamic> preferences,
  });
}

/// @nodoc
class _$TeamMemberCopyWithImpl<$Res, $Val extends TeamMember>
    implements $TeamMemberCopyWith<$Res> {
  _$TeamMemberCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TeamMember
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? role = null,
    Object? contact = null,
    Object? isActive = null,
    Object? expertise = null,
    Object? skills = null,
    Object? availability = null,
    Object? preferences = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            role: null == role
                ? _value.role
                : role // ignore: cast_nullable_to_non_nullable
                      as String,
            contact: null == contact
                ? _value.contact
                : contact // ignore: cast_nullable_to_non_nullable
                      as String,
            isActive: null == isActive
                ? _value.isActive
                : isActive // ignore: cast_nullable_to_non_nullable
                      as bool,
            expertise: null == expertise
                ? _value.expertise
                : expertise // ignore: cast_nullable_to_non_nullable
                      as String,
            skills: null == skills
                ? _value.skills
                : skills // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            availability: null == availability
                ? _value.availability
                : availability // ignore: cast_nullable_to_non_nullable
                      as double,
            preferences: null == preferences
                ? _value.preferences
                : preferences // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$TeamMemberImplCopyWith<$Res>
    implements $TeamMemberCopyWith<$Res> {
  factory _$$TeamMemberImplCopyWith(
    _$TeamMemberImpl value,
    $Res Function(_$TeamMemberImpl) then,
  ) = __$$TeamMemberImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String name,
    String role,
    String contact,
    bool isActive,
    String expertise,
    List<String> skills,
    double availability,
    Map<String, dynamic> preferences,
  });
}

/// @nodoc
class __$$TeamMemberImplCopyWithImpl<$Res>
    extends _$TeamMemberCopyWithImpl<$Res, _$TeamMemberImpl>
    implements _$$TeamMemberImplCopyWith<$Res> {
  __$$TeamMemberImplCopyWithImpl(
    _$TeamMemberImpl _value,
    $Res Function(_$TeamMemberImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of TeamMember
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? role = null,
    Object? contact = null,
    Object? isActive = null,
    Object? expertise = null,
    Object? skills = null,
    Object? availability = null,
    Object? preferences = null,
  }) {
    return _then(
      _$TeamMemberImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        role: null == role
            ? _value.role
            : role // ignore: cast_nullable_to_non_nullable
                  as String,
        contact: null == contact
            ? _value.contact
            : contact // ignore: cast_nullable_to_non_nullable
                  as String,
        isActive: null == isActive
            ? _value.isActive
            : isActive // ignore: cast_nullable_to_non_nullable
                  as bool,
        expertise: null == expertise
            ? _value.expertise
            : expertise // ignore: cast_nullable_to_non_nullable
                  as String,
        skills: null == skills
            ? _value._skills
            : skills // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        availability: null == availability
            ? _value.availability
            : availability // ignore: cast_nullable_to_non_nullable
                  as double,
        preferences: null == preferences
            ? _value._preferences
            : preferences // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$TeamMemberImpl implements _TeamMember {
  const _$TeamMemberImpl({
    required this.id,
    required this.name,
    required this.role,
    required this.contact,
    required this.isActive,
    required this.expertise,
    required final List<String> skills,
    required this.availability,
    required final Map<String, dynamic> preferences,
  }) : _skills = skills,
       _preferences = preferences;

  factory _$TeamMemberImpl.fromJson(Map<String, dynamic> json) =>
      _$$TeamMemberImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String role;
  @override
  final String contact;
  @override
  final bool isActive;
  @override
  final String expertise;
  final List<String> _skills;
  @override
  List<String> get skills {
    if (_skills is EqualUnmodifiableListView) return _skills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_skills);
  }

  @override
  final double availability;
  final Map<String, dynamic> _preferences;
  @override
  Map<String, dynamic> get preferences {
    if (_preferences is EqualUnmodifiableMapView) return _preferences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_preferences);
  }

  @override
  String toString() {
    return 'TeamMember(id: $id, name: $name, role: $role, contact: $contact, isActive: $isActive, expertise: $expertise, skills: $skills, availability: $availability, preferences: $preferences)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TeamMemberImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.contact, contact) || other.contact == contact) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.expertise, expertise) ||
                other.expertise == expertise) &&
            const DeepCollectionEquality().equals(other._skills, _skills) &&
            (identical(other.availability, availability) ||
                other.availability == availability) &&
            const DeepCollectionEquality().equals(
              other._preferences,
              _preferences,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    name,
    role,
    contact,
    isActive,
    expertise,
    const DeepCollectionEquality().hash(_skills),
    availability,
    const DeepCollectionEquality().hash(_preferences),
  );

  /// Create a copy of TeamMember
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TeamMemberImplCopyWith<_$TeamMemberImpl> get copyWith =>
      __$$TeamMemberImplCopyWithImpl<_$TeamMemberImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TeamMemberImplToJson(this);
  }
}

abstract class _TeamMember implements TeamMember {
  const factory _TeamMember({
    required final String id,
    required final String name,
    required final String role,
    required final String contact,
    required final bool isActive,
    required final String expertise,
    required final List<String> skills,
    required final double availability,
    required final Map<String, dynamic> preferences,
  }) = _$TeamMemberImpl;

  factory _TeamMember.fromJson(Map<String, dynamic> json) =
      _$TeamMemberImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get role;
  @override
  String get contact;
  @override
  bool get isActive;
  @override
  String get expertise;
  @override
  List<String> get skills;
  @override
  double get availability;
  @override
  Map<String, dynamic> get preferences;

  /// Create a copy of TeamMember
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TeamMemberImplCopyWith<_$TeamMemberImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ProjectDecision _$ProjectDecisionFromJson(Map<String, dynamic> json) {
  return _ProjectDecision.fromJson(json);
}

/// @nodoc
mixin _$ProjectDecision {
  String get id => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  String get author => throw _privateConstructorUsedError;
  List<String> get reasons => throw _privateConstructorUsedError;
  List<String> get consequences => throw _privateConstructorUsedError;

  /// Serializes this ProjectDecision to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ProjectDecision
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProjectDecisionCopyWith<ProjectDecision> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProjectDecisionCopyWith<$Res> {
  factory $ProjectDecisionCopyWith(
    ProjectDecision value,
    $Res Function(ProjectDecision) then,
  ) = _$ProjectDecisionCopyWithImpl<$Res, ProjectDecision>;
  @useResult
  $Res call({
    String id,
    String description,
    DateTime date,
    String author,
    List<String> reasons,
    List<String> consequences,
  });
}

/// @nodoc
class _$ProjectDecisionCopyWithImpl<$Res, $Val extends ProjectDecision>
    implements $ProjectDecisionCopyWith<$Res> {
  _$ProjectDecisionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProjectDecision
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? date = null,
    Object? author = null,
    Object? reasons = null,
    Object? consequences = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            date: null == date
                ? _value.date
                : date // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            author: null == author
                ? _value.author
                : author // ignore: cast_nullable_to_non_nullable
                      as String,
            reasons: null == reasons
                ? _value.reasons
                : reasons // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            consequences: null == consequences
                ? _value.consequences
                : consequences // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ProjectDecisionImplCopyWith<$Res>
    implements $ProjectDecisionCopyWith<$Res> {
  factory _$$ProjectDecisionImplCopyWith(
    _$ProjectDecisionImpl value,
    $Res Function(_$ProjectDecisionImpl) then,
  ) = __$$ProjectDecisionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String description,
    DateTime date,
    String author,
    List<String> reasons,
    List<String> consequences,
  });
}

/// @nodoc
class __$$ProjectDecisionImplCopyWithImpl<$Res>
    extends _$ProjectDecisionCopyWithImpl<$Res, _$ProjectDecisionImpl>
    implements _$$ProjectDecisionImplCopyWith<$Res> {
  __$$ProjectDecisionImplCopyWithImpl(
    _$ProjectDecisionImpl _value,
    $Res Function(_$ProjectDecisionImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ProjectDecision
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? date = null,
    Object? author = null,
    Object? reasons = null,
    Object? consequences = null,
  }) {
    return _then(
      _$ProjectDecisionImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        author: null == author
            ? _value.author
            : author // ignore: cast_nullable_to_non_nullable
                  as String,
        reasons: null == reasons
            ? _value._reasons
            : reasons // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        consequences: null == consequences
            ? _value._consequences
            : consequences // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ProjectDecisionImpl implements _ProjectDecision {
  const _$ProjectDecisionImpl({
    required this.id,
    required this.description,
    required this.date,
    required this.author,
    required final List<String> reasons,
    required final List<String> consequences,
  }) : _reasons = reasons,
       _consequences = consequences;

  factory _$ProjectDecisionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ProjectDecisionImplFromJson(json);

  @override
  final String id;
  @override
  final String description;
  @override
  final DateTime date;
  @override
  final String author;
  final List<String> _reasons;
  @override
  List<String> get reasons {
    if (_reasons is EqualUnmodifiableListView) return _reasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reasons);
  }

  final List<String> _consequences;
  @override
  List<String> get consequences {
    if (_consequences is EqualUnmodifiableListView) return _consequences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_consequences);
  }

  @override
  String toString() {
    return 'ProjectDecision(id: $id, description: $description, date: $date, author: $author, reasons: $reasons, consequences: $consequences)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProjectDecisionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.author, author) || other.author == author) &&
            const DeepCollectionEquality().equals(other._reasons, _reasons) &&
            const DeepCollectionEquality().equals(
              other._consequences,
              _consequences,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    description,
    date,
    author,
    const DeepCollectionEquality().hash(_reasons),
    const DeepCollectionEquality().hash(_consequences),
  );

  /// Create a copy of ProjectDecision
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProjectDecisionImplCopyWith<_$ProjectDecisionImpl> get copyWith =>
      __$$ProjectDecisionImplCopyWithImpl<_$ProjectDecisionImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ProjectDecisionImplToJson(this);
  }
}

abstract class _ProjectDecision implements ProjectDecision {
  const factory _ProjectDecision({
    required final String id,
    required final String description,
    required final DateTime date,
    required final String author,
    required final List<String> reasons,
    required final List<String> consequences,
  }) = _$ProjectDecisionImpl;

  factory _ProjectDecision.fromJson(Map<String, dynamic> json) =
      _$ProjectDecisionImpl.fromJson;

  @override
  String get id;
  @override
  String get description;
  @override
  DateTime get date;
  @override
  String get author;
  @override
  List<String> get reasons;
  @override
  List<String> get consequences;

  /// Create a copy of ProjectDecision
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProjectDecisionImplCopyWith<_$ProjectDecisionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LessonLearned _$LessonLearnedFromJson(Map<String, dynamic> json) {
  return _LessonLearned.fromJson(json);
}

/// @nodoc
mixin _$LessonLearned {
  String get id => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  String get author => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;

  /// Serializes this LessonLearned to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LessonLearned
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LessonLearnedCopyWith<LessonLearned> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LessonLearnedCopyWith<$Res> {
  factory $LessonLearnedCopyWith(
    LessonLearned value,
    $Res Function(LessonLearned) then,
  ) = _$LessonLearnedCopyWithImpl<$Res, LessonLearned>;
  @useResult
  $Res call({
    String id,
    String description,
    DateTime date,
    String author,
    List<String> tags,
  });
}

/// @nodoc
class _$LessonLearnedCopyWithImpl<$Res, $Val extends LessonLearned>
    implements $LessonLearnedCopyWith<$Res> {
  _$LessonLearnedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LessonLearned
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? date = null,
    Object? author = null,
    Object? tags = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            description: null == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String,
            date: null == date
                ? _value.date
                : date // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            author: null == author
                ? _value.author
                : author // ignore: cast_nullable_to_non_nullable
                      as String,
            tags: null == tags
                ? _value.tags
                : tags // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$LessonLearnedImplCopyWith<$Res>
    implements $LessonLearnedCopyWith<$Res> {
  factory _$$LessonLearnedImplCopyWith(
    _$LessonLearnedImpl value,
    $Res Function(_$LessonLearnedImpl) then,
  ) = __$$LessonLearnedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String description,
    DateTime date,
    String author,
    List<String> tags,
  });
}

/// @nodoc
class __$$LessonLearnedImplCopyWithImpl<$Res>
    extends _$LessonLearnedCopyWithImpl<$Res, _$LessonLearnedImpl>
    implements _$$LessonLearnedImplCopyWith<$Res> {
  __$$LessonLearnedImplCopyWithImpl(
    _$LessonLearnedImpl _value,
    $Res Function(_$LessonLearnedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of LessonLearned
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? description = null,
    Object? date = null,
    Object? author = null,
    Object? tags = null,
  }) {
    return _then(
      _$LessonLearnedImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        description: null == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        author: null == author
            ? _value.author
            : author // ignore: cast_nullable_to_non_nullable
                  as String,
        tags: null == tags
            ? _value._tags
            : tags // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$LessonLearnedImpl implements _LessonLearned {
  const _$LessonLearnedImpl({
    required this.id,
    required this.description,
    required this.date,
    required this.author,
    required final List<String> tags,
  }) : _tags = tags;

  factory _$LessonLearnedImpl.fromJson(Map<String, dynamic> json) =>
      _$$LessonLearnedImplFromJson(json);

  @override
  final String id;
  @override
  final String description;
  @override
  final DateTime date;
  @override
  final String author;
  final List<String> _tags;
  @override
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  String toString() {
    return 'LessonLearned(id: $id, description: $description, date: $date, author: $author, tags: $tags)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LessonLearnedImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.author, author) || other.author == author) &&
            const DeepCollectionEquality().equals(other._tags, _tags));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    description,
    date,
    author,
    const DeepCollectionEquality().hash(_tags),
  );

  /// Create a copy of LessonLearned
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LessonLearnedImplCopyWith<_$LessonLearnedImpl> get copyWith =>
      __$$LessonLearnedImplCopyWithImpl<_$LessonLearnedImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LessonLearnedImplToJson(this);
  }
}

abstract class _LessonLearned implements LessonLearned {
  const factory _LessonLearned({
    required final String id,
    required final String description,
    required final DateTime date,
    required final String author,
    required final List<String> tags,
  }) = _$LessonLearnedImpl;

  factory _LessonLearned.fromJson(Map<String, dynamic> json) =
      _$LessonLearnedImpl.fromJson;

  @override
  String get id;
  @override
  String get description;
  @override
  DateTime get date;
  @override
  String get author;
  @override
  List<String> get tags;

  /// Create a copy of LessonLearned
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LessonLearnedImplCopyWith<_$LessonLearnedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

WorkflowConfiguration _$WorkflowConfigurationFromJson(
  Map<String, dynamic> json,
) {
  return _WorkflowConfiguration.fromJson(json);
}

/// @nodoc
mixin _$WorkflowConfiguration {
  List<String> get enabledResearchSources => throw _privateConstructorUsedError;
  List<EthicalConcern> get ethicalConcerns =>
      throw _privateConstructorUsedError;
  int get maxResearchResults => throw _privateConstructorUsedError;
  Map<String, dynamic> get assetGenerationSettings =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> get engineConfig => throw _privateConstructorUsedError;
  Map<String, dynamic> get codeGenerationOptions =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> get buildConfig => throw _privateConstructorUsedError;

  /// Serializes this WorkflowConfiguration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkflowConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkflowConfigurationCopyWith<WorkflowConfiguration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkflowConfigurationCopyWith<$Res> {
  factory $WorkflowConfigurationCopyWith(
    WorkflowConfiguration value,
    $Res Function(WorkflowConfiguration) then,
  ) = _$WorkflowConfigurationCopyWithImpl<$Res, WorkflowConfiguration>;
  @useResult
  $Res call({
    List<String> enabledResearchSources,
    List<EthicalConcern> ethicalConcerns,
    int maxResearchResults,
    Map<String, dynamic> assetGenerationSettings,
    Map<String, dynamic> engineConfig,
    Map<String, dynamic> codeGenerationOptions,
    Map<String, dynamic> buildConfig,
  });
}

/// @nodoc
class _$WorkflowConfigurationCopyWithImpl<
  $Res,
  $Val extends WorkflowConfiguration
>
    implements $WorkflowConfigurationCopyWith<$Res> {
  _$WorkflowConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkflowConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabledResearchSources = null,
    Object? ethicalConcerns = null,
    Object? maxResearchResults = null,
    Object? assetGenerationSettings = null,
    Object? engineConfig = null,
    Object? codeGenerationOptions = null,
    Object? buildConfig = null,
  }) {
    return _then(
      _value.copyWith(
            enabledResearchSources: null == enabledResearchSources
                ? _value.enabledResearchSources
                : enabledResearchSources // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            ethicalConcerns: null == ethicalConcerns
                ? _value.ethicalConcerns
                : ethicalConcerns // ignore: cast_nullable_to_non_nullable
                      as List<EthicalConcern>,
            maxResearchResults: null == maxResearchResults
                ? _value.maxResearchResults
                : maxResearchResults // ignore: cast_nullable_to_non_nullable
                      as int,
            assetGenerationSettings: null == assetGenerationSettings
                ? _value.assetGenerationSettings
                : assetGenerationSettings // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            engineConfig: null == engineConfig
                ? _value.engineConfig
                : engineConfig // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            codeGenerationOptions: null == codeGenerationOptions
                ? _value.codeGenerationOptions
                : codeGenerationOptions // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
            buildConfig: null == buildConfig
                ? _value.buildConfig
                : buildConfig // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$WorkflowConfigurationImplCopyWith<$Res>
    implements $WorkflowConfigurationCopyWith<$Res> {
  factory _$$WorkflowConfigurationImplCopyWith(
    _$WorkflowConfigurationImpl value,
    $Res Function(_$WorkflowConfigurationImpl) then,
  ) = __$$WorkflowConfigurationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<String> enabledResearchSources,
    List<EthicalConcern> ethicalConcerns,
    int maxResearchResults,
    Map<String, dynamic> assetGenerationSettings,
    Map<String, dynamic> engineConfig,
    Map<String, dynamic> codeGenerationOptions,
    Map<String, dynamic> buildConfig,
  });
}

/// @nodoc
class __$$WorkflowConfigurationImplCopyWithImpl<$Res>
    extends
        _$WorkflowConfigurationCopyWithImpl<$Res, _$WorkflowConfigurationImpl>
    implements _$$WorkflowConfigurationImplCopyWith<$Res> {
  __$$WorkflowConfigurationImplCopyWithImpl(
    _$WorkflowConfigurationImpl _value,
    $Res Function(_$WorkflowConfigurationImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of WorkflowConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabledResearchSources = null,
    Object? ethicalConcerns = null,
    Object? maxResearchResults = null,
    Object? assetGenerationSettings = null,
    Object? engineConfig = null,
    Object? codeGenerationOptions = null,
    Object? buildConfig = null,
  }) {
    return _then(
      _$WorkflowConfigurationImpl(
        enabledResearchSources: null == enabledResearchSources
            ? _value._enabledResearchSources
            : enabledResearchSources // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        ethicalConcerns: null == ethicalConcerns
            ? _value._ethicalConcerns
            : ethicalConcerns // ignore: cast_nullable_to_non_nullable
                  as List<EthicalConcern>,
        maxResearchResults: null == maxResearchResults
            ? _value.maxResearchResults
            : maxResearchResults // ignore: cast_nullable_to_non_nullable
                  as int,
        assetGenerationSettings: null == assetGenerationSettings
            ? _value._assetGenerationSettings
            : assetGenerationSettings // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        engineConfig: null == engineConfig
            ? _value._engineConfig
            : engineConfig // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        codeGenerationOptions: null == codeGenerationOptions
            ? _value._codeGenerationOptions
            : codeGenerationOptions // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
        buildConfig: null == buildConfig
            ? _value._buildConfig
            : buildConfig // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkflowConfigurationImpl implements _WorkflowConfiguration {
  const _$WorkflowConfigurationImpl({
    required final List<String> enabledResearchSources,
    required final List<EthicalConcern> ethicalConcerns,
    required this.maxResearchResults,
    required final Map<String, dynamic> assetGenerationSettings,
    required final Map<String, dynamic> engineConfig,
    required final Map<String, dynamic> codeGenerationOptions,
    required final Map<String, dynamic> buildConfig,
  }) : _enabledResearchSources = enabledResearchSources,
       _ethicalConcerns = ethicalConcerns,
       _assetGenerationSettings = assetGenerationSettings,
       _engineConfig = engineConfig,
       _codeGenerationOptions = codeGenerationOptions,
       _buildConfig = buildConfig;

  factory _$WorkflowConfigurationImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkflowConfigurationImplFromJson(json);

  final List<String> _enabledResearchSources;
  @override
  List<String> get enabledResearchSources {
    if (_enabledResearchSources is EqualUnmodifiableListView)
      return _enabledResearchSources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_enabledResearchSources);
  }

  final List<EthicalConcern> _ethicalConcerns;
  @override
  List<EthicalConcern> get ethicalConcerns {
    if (_ethicalConcerns is EqualUnmodifiableListView) return _ethicalConcerns;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_ethicalConcerns);
  }

  @override
  final int maxResearchResults;
  final Map<String, dynamic> _assetGenerationSettings;
  @override
  Map<String, dynamic> get assetGenerationSettings {
    if (_assetGenerationSettings is EqualUnmodifiableMapView)
      return _assetGenerationSettings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_assetGenerationSettings);
  }

  final Map<String, dynamic> _engineConfig;
  @override
  Map<String, dynamic> get engineConfig {
    if (_engineConfig is EqualUnmodifiableMapView) return _engineConfig;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_engineConfig);
  }

  final Map<String, dynamic> _codeGenerationOptions;
  @override
  Map<String, dynamic> get codeGenerationOptions {
    if (_codeGenerationOptions is EqualUnmodifiableMapView)
      return _codeGenerationOptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_codeGenerationOptions);
  }

  final Map<String, dynamic> _buildConfig;
  @override
  Map<String, dynamic> get buildConfig {
    if (_buildConfig is EqualUnmodifiableMapView) return _buildConfig;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_buildConfig);
  }

  @override
  String toString() {
    return 'WorkflowConfiguration(enabledResearchSources: $enabledResearchSources, ethicalConcerns: $ethicalConcerns, maxResearchResults: $maxResearchResults, assetGenerationSettings: $assetGenerationSettings, engineConfig: $engineConfig, codeGenerationOptions: $codeGenerationOptions, buildConfig: $buildConfig)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkflowConfigurationImpl &&
            const DeepCollectionEquality().equals(
              other._enabledResearchSources,
              _enabledResearchSources,
            ) &&
            const DeepCollectionEquality().equals(
              other._ethicalConcerns,
              _ethicalConcerns,
            ) &&
            (identical(other.maxResearchResults, maxResearchResults) ||
                other.maxResearchResults == maxResearchResults) &&
            const DeepCollectionEquality().equals(
              other._assetGenerationSettings,
              _assetGenerationSettings,
            ) &&
            const DeepCollectionEquality().equals(
              other._engineConfig,
              _engineConfig,
            ) &&
            const DeepCollectionEquality().equals(
              other._codeGenerationOptions,
              _codeGenerationOptions,
            ) &&
            const DeepCollectionEquality().equals(
              other._buildConfig,
              _buildConfig,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_enabledResearchSources),
    const DeepCollectionEquality().hash(_ethicalConcerns),
    maxResearchResults,
    const DeepCollectionEquality().hash(_assetGenerationSettings),
    const DeepCollectionEquality().hash(_engineConfig),
    const DeepCollectionEquality().hash(_codeGenerationOptions),
    const DeepCollectionEquality().hash(_buildConfig),
  );

  /// Create a copy of WorkflowConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkflowConfigurationImplCopyWith<_$WorkflowConfigurationImpl>
  get copyWith =>
      __$$WorkflowConfigurationImplCopyWithImpl<_$WorkflowConfigurationImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkflowConfigurationImplToJson(this);
  }
}

abstract class _WorkflowConfiguration implements WorkflowConfiguration {
  const factory _WorkflowConfiguration({
    required final List<String> enabledResearchSources,
    required final List<EthicalConcern> ethicalConcerns,
    required final int maxResearchResults,
    required final Map<String, dynamic> assetGenerationSettings,
    required final Map<String, dynamic> engineConfig,
    required final Map<String, dynamic> codeGenerationOptions,
    required final Map<String, dynamic> buildConfig,
  }) = _$WorkflowConfigurationImpl;

  factory _WorkflowConfiguration.fromJson(Map<String, dynamic> json) =
      _$WorkflowConfigurationImpl.fromJson;

  @override
  List<String> get enabledResearchSources;
  @override
  List<EthicalConcern> get ethicalConcerns;
  @override
  int get maxResearchResults;
  @override
  Map<String, dynamic> get assetGenerationSettings;
  @override
  Map<String, dynamic> get engineConfig;
  @override
  Map<String, dynamic> get codeGenerationOptions;
  @override
  Map<String, dynamic> get buildConfig;

  /// Create a copy of WorkflowConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkflowConfigurationImplCopyWith<_$WorkflowConfigurationImpl>
  get copyWith => throw _privateConstructorUsedError;
}

WorkflowStatus _$WorkflowStatusFromJson(Map<String, dynamic> json) {
  return _WorkflowStatus.fromJson(json);
}

/// @nodoc
mixin _$WorkflowStatus {
  String get workflowId => throw _privateConstructorUsedError;
  WorkflowType get type => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  double get progress => throw _privateConstructorUsedError;
  DateTime get startTime => throw _privateConstructorUsedError;
  DateTime? get endTime => throw _privateConstructorUsedError;
  List<String> get logs => throw _privateConstructorUsedError;
  List<String> get warnings => throw _privateConstructorUsedError;
  List<String> get errors => throw _privateConstructorUsedError;
  String? get currentStep => throw _privateConstructorUsedError;
  Duration? get estimatedTimeRemaining => throw _privateConstructorUsedError;

  /// Serializes this WorkflowStatus to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkflowStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkflowStatusCopyWith<WorkflowStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkflowStatusCopyWith<$Res> {
  factory $WorkflowStatusCopyWith(
    WorkflowStatus value,
    $Res Function(WorkflowStatus) then,
  ) = _$WorkflowStatusCopyWithImpl<$Res, WorkflowStatus>;
  @useResult
  $Res call({
    String workflowId,
    WorkflowType type,
    String status,
    double progress,
    DateTime startTime,
    DateTime? endTime,
    List<String> logs,
    List<String> warnings,
    List<String> errors,
    String? currentStep,
    Duration? estimatedTimeRemaining,
  });
}

/// @nodoc
class _$WorkflowStatusCopyWithImpl<$Res, $Val extends WorkflowStatus>
    implements $WorkflowStatusCopyWith<$Res> {
  _$WorkflowStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkflowStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowId = null,
    Object? type = null,
    Object? status = null,
    Object? progress = null,
    Object? startTime = null,
    Object? endTime = freezed,
    Object? logs = null,
    Object? warnings = null,
    Object? errors = null,
    Object? currentStep = freezed,
    Object? estimatedTimeRemaining = freezed,
  }) {
    return _then(
      _value.copyWith(
            workflowId: null == workflowId
                ? _value.workflowId
                : workflowId // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as WorkflowType,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as String,
            progress: null == progress
                ? _value.progress
                : progress // ignore: cast_nullable_to_non_nullable
                      as double,
            startTime: null == startTime
                ? _value.startTime
                : startTime // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            endTime: freezed == endTime
                ? _value.endTime
                : endTime // ignore: cast_nullable_to_non_nullable
                      as DateTime?,
            logs: null == logs
                ? _value.logs
                : logs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            warnings: null == warnings
                ? _value.warnings
                : warnings // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            errors: null == errors
                ? _value.errors
                : errors // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            currentStep: freezed == currentStep
                ? _value.currentStep
                : currentStep // ignore: cast_nullable_to_non_nullable
                      as String?,
            estimatedTimeRemaining: freezed == estimatedTimeRemaining
                ? _value.estimatedTimeRemaining
                : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
                      as Duration?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$WorkflowStatusImplCopyWith<$Res>
    implements $WorkflowStatusCopyWith<$Res> {
  factory _$$WorkflowStatusImplCopyWith(
    _$WorkflowStatusImpl value,
    $Res Function(_$WorkflowStatusImpl) then,
  ) = __$$WorkflowStatusImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String workflowId,
    WorkflowType type,
    String status,
    double progress,
    DateTime startTime,
    DateTime? endTime,
    List<String> logs,
    List<String> warnings,
    List<String> errors,
    String? currentStep,
    Duration? estimatedTimeRemaining,
  });
}

/// @nodoc
class __$$WorkflowStatusImplCopyWithImpl<$Res>
    extends _$WorkflowStatusCopyWithImpl<$Res, _$WorkflowStatusImpl>
    implements _$$WorkflowStatusImplCopyWith<$Res> {
  __$$WorkflowStatusImplCopyWithImpl(
    _$WorkflowStatusImpl _value,
    $Res Function(_$WorkflowStatusImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of WorkflowStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowId = null,
    Object? type = null,
    Object? status = null,
    Object? progress = null,
    Object? startTime = null,
    Object? endTime = freezed,
    Object? logs = null,
    Object? warnings = null,
    Object? errors = null,
    Object? currentStep = freezed,
    Object? estimatedTimeRemaining = freezed,
  }) {
    return _then(
      _$WorkflowStatusImpl(
        workflowId: null == workflowId
            ? _value.workflowId
            : workflowId // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as WorkflowType,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as String,
        progress: null == progress
            ? _value.progress
            : progress // ignore: cast_nullable_to_non_nullable
                  as double,
        startTime: null == startTime
            ? _value.startTime
            : startTime // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        endTime: freezed == endTime
            ? _value.endTime
            : endTime // ignore: cast_nullable_to_non_nullable
                  as DateTime?,
        logs: null == logs
            ? _value._logs
            : logs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        warnings: null == warnings
            ? _value._warnings
            : warnings // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        errors: null == errors
            ? _value._errors
            : errors // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        currentStep: freezed == currentStep
            ? _value.currentStep
            : currentStep // ignore: cast_nullable_to_non_nullable
                  as String?,
        estimatedTimeRemaining: freezed == estimatedTimeRemaining
            ? _value.estimatedTimeRemaining
            : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
                  as Duration?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkflowStatusImpl implements _WorkflowStatus {
  const _$WorkflowStatusImpl({
    required this.workflowId,
    required this.type,
    required this.status,
    required this.progress,
    required this.startTime,
    this.endTime,
    required final List<String> logs,
    required final List<String> warnings,
    required final List<String> errors,
    this.currentStep,
    this.estimatedTimeRemaining,
  }) : _logs = logs,
       _warnings = warnings,
       _errors = errors;

  factory _$WorkflowStatusImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkflowStatusImplFromJson(json);

  @override
  final String workflowId;
  @override
  final WorkflowType type;
  @override
  final String status;
  @override
  final double progress;
  @override
  final DateTime startTime;
  @override
  final DateTime? endTime;
  final List<String> _logs;
  @override
  List<String> get logs {
    if (_logs is EqualUnmodifiableListView) return _logs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_logs);
  }

  final List<String> _warnings;
  @override
  List<String> get warnings {
    if (_warnings is EqualUnmodifiableListView) return _warnings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_warnings);
  }

  final List<String> _errors;
  @override
  List<String> get errors {
    if (_errors is EqualUnmodifiableListView) return _errors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_errors);
  }

  @override
  final String? currentStep;
  @override
  final Duration? estimatedTimeRemaining;

  @override
  String toString() {
    return 'WorkflowStatus(workflowId: $workflowId, type: $type, status: $status, progress: $progress, startTime: $startTime, endTime: $endTime, logs: $logs, warnings: $warnings, errors: $errors, currentStep: $currentStep, estimatedTimeRemaining: $estimatedTimeRemaining)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkflowStatusImpl &&
            (identical(other.workflowId, workflowId) ||
                other.workflowId == workflowId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.progress, progress) ||
                other.progress == progress) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            const DeepCollectionEquality().equals(other._logs, _logs) &&
            const DeepCollectionEquality().equals(other._warnings, _warnings) &&
            const DeepCollectionEquality().equals(other._errors, _errors) &&
            (identical(other.currentStep, currentStep) ||
                other.currentStep == currentStep) &&
            (identical(other.estimatedTimeRemaining, estimatedTimeRemaining) ||
                other.estimatedTimeRemaining == estimatedTimeRemaining));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    workflowId,
    type,
    status,
    progress,
    startTime,
    endTime,
    const DeepCollectionEquality().hash(_logs),
    const DeepCollectionEquality().hash(_warnings),
    const DeepCollectionEquality().hash(_errors),
    currentStep,
    estimatedTimeRemaining,
  );

  /// Create a copy of WorkflowStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkflowStatusImplCopyWith<_$WorkflowStatusImpl> get copyWith =>
      __$$WorkflowStatusImplCopyWithImpl<_$WorkflowStatusImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkflowStatusImplToJson(this);
  }
}

abstract class _WorkflowStatus implements WorkflowStatus {
  const factory _WorkflowStatus({
    required final String workflowId,
    required final WorkflowType type,
    required final String status,
    required final double progress,
    required final DateTime startTime,
    final DateTime? endTime,
    required final List<String> logs,
    required final List<String> warnings,
    required final List<String> errors,
    final String? currentStep,
    final Duration? estimatedTimeRemaining,
  }) = _$WorkflowStatusImpl;

  factory _WorkflowStatus.fromJson(Map<String, dynamic> json) =
      _$WorkflowStatusImpl.fromJson;

  @override
  String get workflowId;
  @override
  WorkflowType get type;
  @override
  String get status;
  @override
  double get progress;
  @override
  DateTime get startTime;
  @override
  DateTime? get endTime;
  @override
  List<String> get logs;
  @override
  List<String> get warnings;
  @override
  List<String> get errors;
  @override
  String? get currentStep;
  @override
  Duration? get estimatedTimeRemaining;

  /// Create a copy of WorkflowStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkflowStatusImplCopyWith<_$WorkflowStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EngineBuildResult _$EngineBuildResultFromJson(Map<String, dynamic> json) {
  return _EngineBuildResult.fromJson(json);
}

/// @nodoc
mixin _$EngineBuildResult {
  bool get success => throw _privateConstructorUsedError;
  String get engine => throw _privateConstructorUsedError;
  String get platform => throw _privateConstructorUsedError;
  String get buildUrl => throw _privateConstructorUsedError;
  DateTime get buildTime => throw _privateConstructorUsedError;
  List<String> get warnings => throw _privateConstructorUsedError;
  List<String> get errors => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this EngineBuildResult to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EngineBuildResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EngineBuildResultCopyWith<EngineBuildResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EngineBuildResultCopyWith<$Res> {
  factory $EngineBuildResultCopyWith(
    EngineBuildResult value,
    $Res Function(EngineBuildResult) then,
  ) = _$EngineBuildResultCopyWithImpl<$Res, EngineBuildResult>;
  @useResult
  $Res call({
    bool success,
    String engine,
    String platform,
    String buildUrl,
    DateTime buildTime,
    List<String> warnings,
    List<String> errors,
    Map<String, dynamic> metadata,
  });
}

/// @nodoc
class _$EngineBuildResultCopyWithImpl<$Res, $Val extends EngineBuildResult>
    implements $EngineBuildResultCopyWith<$Res> {
  _$EngineBuildResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EngineBuildResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? engine = null,
    Object? platform = null,
    Object? buildUrl = null,
    Object? buildTime = null,
    Object? warnings = null,
    Object? errors = null,
    Object? metadata = null,
  }) {
    return _then(
      _value.copyWith(
            success: null == success
                ? _value.success
                : success // ignore: cast_nullable_to_non_nullable
                      as bool,
            engine: null == engine
                ? _value.engine
                : engine // ignore: cast_nullable_to_non_nullable
                      as String,
            platform: null == platform
                ? _value.platform
                : platform // ignore: cast_nullable_to_non_nullable
                      as String,
            buildUrl: null == buildUrl
                ? _value.buildUrl
                : buildUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            buildTime: null == buildTime
                ? _value.buildTime
                : buildTime // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            warnings: null == warnings
                ? _value.warnings
                : warnings // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            errors: null == errors
                ? _value.errors
                : errors // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            metadata: null == metadata
                ? _value.metadata
                : metadata // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$EngineBuildResultImplCopyWith<$Res>
    implements $EngineBuildResultCopyWith<$Res> {
  factory _$$EngineBuildResultImplCopyWith(
    _$EngineBuildResultImpl value,
    $Res Function(_$EngineBuildResultImpl) then,
  ) = __$$EngineBuildResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    bool success,
    String engine,
    String platform,
    String buildUrl,
    DateTime buildTime,
    List<String> warnings,
    List<String> errors,
    Map<String, dynamic> metadata,
  });
}

/// @nodoc
class __$$EngineBuildResultImplCopyWithImpl<$Res>
    extends _$EngineBuildResultCopyWithImpl<$Res, _$EngineBuildResultImpl>
    implements _$$EngineBuildResultImplCopyWith<$Res> {
  __$$EngineBuildResultImplCopyWithImpl(
    _$EngineBuildResultImpl _value,
    $Res Function(_$EngineBuildResultImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of EngineBuildResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? engine = null,
    Object? platform = null,
    Object? buildUrl = null,
    Object? buildTime = null,
    Object? warnings = null,
    Object? errors = null,
    Object? metadata = null,
  }) {
    return _then(
      _$EngineBuildResultImpl(
        success: null == success
            ? _value.success
            : success // ignore: cast_nullable_to_non_nullable
                  as bool,
        engine: null == engine
            ? _value.engine
            : engine // ignore: cast_nullable_to_non_nullable
                  as String,
        platform: null == platform
            ? _value.platform
            : platform // ignore: cast_nullable_to_non_nullable
                  as String,
        buildUrl: null == buildUrl
            ? _value.buildUrl
            : buildUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        buildTime: null == buildTime
            ? _value.buildTime
            : buildTime // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        warnings: null == warnings
            ? _value._warnings
            : warnings // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        errors: null == errors
            ? _value._errors
            : errors // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        metadata: null == metadata
            ? _value._metadata
            : metadata // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$EngineBuildResultImpl implements _EngineBuildResult {
  const _$EngineBuildResultImpl({
    required this.success,
    required this.engine,
    required this.platform,
    required this.buildUrl,
    required this.buildTime,
    required final List<String> warnings,
    required final List<String> errors,
    required final Map<String, dynamic> metadata,
  }) : _warnings = warnings,
       _errors = errors,
       _metadata = metadata;

  factory _$EngineBuildResultImpl.fromJson(Map<String, dynamic> json) =>
      _$$EngineBuildResultImplFromJson(json);

  @override
  final bool success;
  @override
  final String engine;
  @override
  final String platform;
  @override
  final String buildUrl;
  @override
  final DateTime buildTime;
  final List<String> _warnings;
  @override
  List<String> get warnings {
    if (_warnings is EqualUnmodifiableListView) return _warnings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_warnings);
  }

  final List<String> _errors;
  @override
  List<String> get errors {
    if (_errors is EqualUnmodifiableListView) return _errors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_errors);
  }

  final Map<String, dynamic> _metadata;
  @override
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'EngineBuildResult(success: $success, engine: $engine, platform: $platform, buildUrl: $buildUrl, buildTime: $buildTime, warnings: $warnings, errors: $errors, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EngineBuildResultImpl &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.engine, engine) || other.engine == engine) &&
            (identical(other.platform, platform) ||
                other.platform == platform) &&
            (identical(other.buildUrl, buildUrl) ||
                other.buildUrl == buildUrl) &&
            (identical(other.buildTime, buildTime) ||
                other.buildTime == buildTime) &&
            const DeepCollectionEquality().equals(other._warnings, _warnings) &&
            const DeepCollectionEquality().equals(other._errors, _errors) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    success,
    engine,
    platform,
    buildUrl,
    buildTime,
    const DeepCollectionEquality().hash(_warnings),
    const DeepCollectionEquality().hash(_errors),
    const DeepCollectionEquality().hash(_metadata),
  );

  /// Create a copy of EngineBuildResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EngineBuildResultImplCopyWith<_$EngineBuildResultImpl> get copyWith =>
      __$$EngineBuildResultImplCopyWithImpl<_$EngineBuildResultImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$EngineBuildResultImplToJson(this);
  }
}

abstract class _EngineBuildResult implements EngineBuildResult {
  const factory _EngineBuildResult({
    required final bool success,
    required final String engine,
    required final String platform,
    required final String buildUrl,
    required final DateTime buildTime,
    required final List<String> warnings,
    required final List<String> errors,
    required final Map<String, dynamic> metadata,
  }) = _$EngineBuildResultImpl;

  factory _EngineBuildResult.fromJson(Map<String, dynamic> json) =
      _$EngineBuildResultImpl.fromJson;

  @override
  bool get success;
  @override
  String get engine;
  @override
  String get platform;
  @override
  String get buildUrl;
  @override
  DateTime get buildTime;
  @override
  List<String> get warnings;
  @override
  List<String> get errors;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of EngineBuildResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EngineBuildResultImplCopyWith<_$EngineBuildResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrchestrationResult _$OrchestrationResultFromJson(Map<String, dynamic> json) {
  return _OrchestrationResult.fromJson(json);
}

/// @nodoc
mixin _$OrchestrationResult {
  String get workflowId => throw _privateConstructorUsedError;
  bool get success => throw _privateConstructorUsedError;
  ResearchResult? get researchResult => throw _privateConstructorUsedError;
  GameDesignDocument? get designResult => throw _privateConstructorUsedError;
  List<GeneratedAsset>? get assetResult => throw _privateConstructorUsedError;
  EngineBuildResult? get engineResult => throw _privateConstructorUsedError;
  List<String> get logs => throw _privateConstructorUsedError;
  List<String> get warnings => throw _privateConstructorUsedError;
  Duration get totalDuration => throw _privateConstructorUsedError;

  /// Serializes this OrchestrationResult to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrchestrationResultCopyWith<OrchestrationResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrchestrationResultCopyWith<$Res> {
  factory $OrchestrationResultCopyWith(
    OrchestrationResult value,
    $Res Function(OrchestrationResult) then,
  ) = _$OrchestrationResultCopyWithImpl<$Res, OrchestrationResult>;
  @useResult
  $Res call({
    String workflowId,
    bool success,
    ResearchResult? researchResult,
    GameDesignDocument? designResult,
    List<GeneratedAsset>? assetResult,
    EngineBuildResult? engineResult,
    List<String> logs,
    List<String> warnings,
    Duration totalDuration,
  });

  $ResearchResultCopyWith<$Res>? get researchResult;
  $GameDesignDocumentCopyWith<$Res>? get designResult;
  $EngineBuildResultCopyWith<$Res>? get engineResult;
}

/// @nodoc
class _$OrchestrationResultCopyWithImpl<$Res, $Val extends OrchestrationResult>
    implements $OrchestrationResultCopyWith<$Res> {
  _$OrchestrationResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowId = null,
    Object? success = null,
    Object? researchResult = freezed,
    Object? designResult = freezed,
    Object? assetResult = freezed,
    Object? engineResult = freezed,
    Object? logs = null,
    Object? warnings = null,
    Object? totalDuration = null,
  }) {
    return _then(
      _value.copyWith(
            workflowId: null == workflowId
                ? _value.workflowId
                : workflowId // ignore: cast_nullable_to_non_nullable
                      as String,
            success: null == success
                ? _value.success
                : success // ignore: cast_nullable_to_non_nullable
                      as bool,
            researchResult: freezed == researchResult
                ? _value.researchResult
                : researchResult // ignore: cast_nullable_to_non_nullable
                      as ResearchResult?,
            designResult: freezed == designResult
                ? _value.designResult
                : designResult // ignore: cast_nullable_to_non_nullable
                      as GameDesignDocument?,
            assetResult: freezed == assetResult
                ? _value.assetResult
                : assetResult // ignore: cast_nullable_to_non_nullable
                      as List<GeneratedAsset>?,
            engineResult: freezed == engineResult
                ? _value.engineResult
                : engineResult // ignore: cast_nullable_to_non_nullable
                      as EngineBuildResult?,
            logs: null == logs
                ? _value.logs
                : logs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            warnings: null == warnings
                ? _value.warnings
                : warnings // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            totalDuration: null == totalDuration
                ? _value.totalDuration
                : totalDuration // ignore: cast_nullable_to_non_nullable
                      as Duration,
          )
          as $Val,
    );
  }

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResearchResultCopyWith<$Res>? get researchResult {
    if (_value.researchResult == null) {
      return null;
    }

    return $ResearchResultCopyWith<$Res>(_value.researchResult!, (value) {
      return _then(_value.copyWith(researchResult: value) as $Val);
    });
  }

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GameDesignDocumentCopyWith<$Res>? get designResult {
    if (_value.designResult == null) {
      return null;
    }

    return $GameDesignDocumentCopyWith<$Res>(_value.designResult!, (value) {
      return _then(_value.copyWith(designResult: value) as $Val);
    });
  }

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EngineBuildResultCopyWith<$Res>? get engineResult {
    if (_value.engineResult == null) {
      return null;
    }

    return $EngineBuildResultCopyWith<$Res>(_value.engineResult!, (value) {
      return _then(_value.copyWith(engineResult: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OrchestrationResultImplCopyWith<$Res>
    implements $OrchestrationResultCopyWith<$Res> {
  factory _$$OrchestrationResultImplCopyWith(
    _$OrchestrationResultImpl value,
    $Res Function(_$OrchestrationResultImpl) then,
  ) = __$$OrchestrationResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String workflowId,
    bool success,
    ResearchResult? researchResult,
    GameDesignDocument? designResult,
    List<GeneratedAsset>? assetResult,
    EngineBuildResult? engineResult,
    List<String> logs,
    List<String> warnings,
    Duration totalDuration,
  });

  @override
  $ResearchResultCopyWith<$Res>? get researchResult;
  @override
  $GameDesignDocumentCopyWith<$Res>? get designResult;
  @override
  $EngineBuildResultCopyWith<$Res>? get engineResult;
}

/// @nodoc
class __$$OrchestrationResultImplCopyWithImpl<$Res>
    extends _$OrchestrationResultCopyWithImpl<$Res, _$OrchestrationResultImpl>
    implements _$$OrchestrationResultImplCopyWith<$Res> {
  __$$OrchestrationResultImplCopyWithImpl(
    _$OrchestrationResultImpl _value,
    $Res Function(_$OrchestrationResultImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workflowId = null,
    Object? success = null,
    Object? researchResult = freezed,
    Object? designResult = freezed,
    Object? assetResult = freezed,
    Object? engineResult = freezed,
    Object? logs = null,
    Object? warnings = null,
    Object? totalDuration = null,
  }) {
    return _then(
      _$OrchestrationResultImpl(
        workflowId: null == workflowId
            ? _value.workflowId
            : workflowId // ignore: cast_nullable_to_non_nullable
                  as String,
        success: null == success
            ? _value.success
            : success // ignore: cast_nullable_to_non_nullable
                  as bool,
        researchResult: freezed == researchResult
            ? _value.researchResult
            : researchResult // ignore: cast_nullable_to_non_nullable
                  as ResearchResult?,
        designResult: freezed == designResult
            ? _value.designResult
            : designResult // ignore: cast_nullable_to_non_nullable
                  as GameDesignDocument?,
        assetResult: freezed == assetResult
            ? _value._assetResult
            : assetResult // ignore: cast_nullable_to_non_nullable
                  as List<GeneratedAsset>?,
        engineResult: freezed == engineResult
            ? _value.engineResult
            : engineResult // ignore: cast_nullable_to_non_nullable
                  as EngineBuildResult?,
        logs: null == logs
            ? _value._logs
            : logs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        warnings: null == warnings
            ? _value._warnings
            : warnings // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        totalDuration: null == totalDuration
            ? _value.totalDuration
            : totalDuration // ignore: cast_nullable_to_non_nullable
                  as Duration,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrchestrationResultImpl implements _OrchestrationResult {
  const _$OrchestrationResultImpl({
    required this.workflowId,
    required this.success,
    required this.researchResult,
    required this.designResult,
    required final List<GeneratedAsset>? assetResult,
    required this.engineResult,
    required final List<String> logs,
    required final List<String> warnings,
    required this.totalDuration,
  }) : _assetResult = assetResult,
       _logs = logs,
       _warnings = warnings;

  factory _$OrchestrationResultImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrchestrationResultImplFromJson(json);

  @override
  final String workflowId;
  @override
  final bool success;
  @override
  final ResearchResult? researchResult;
  @override
  final GameDesignDocument? designResult;
  final List<GeneratedAsset>? _assetResult;
  @override
  List<GeneratedAsset>? get assetResult {
    final value = _assetResult;
    if (value == null) return null;
    if (_assetResult is EqualUnmodifiableListView) return _assetResult;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final EngineBuildResult? engineResult;
  final List<String> _logs;
  @override
  List<String> get logs {
    if (_logs is EqualUnmodifiableListView) return _logs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_logs);
  }

  final List<String> _warnings;
  @override
  List<String> get warnings {
    if (_warnings is EqualUnmodifiableListView) return _warnings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_warnings);
  }

  @override
  final Duration totalDuration;

  @override
  String toString() {
    return 'OrchestrationResult(workflowId: $workflowId, success: $success, researchResult: $researchResult, designResult: $designResult, assetResult: $assetResult, engineResult: $engineResult, logs: $logs, warnings: $warnings, totalDuration: $totalDuration)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrchestrationResultImpl &&
            (identical(other.workflowId, workflowId) ||
                other.workflowId == workflowId) &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.researchResult, researchResult) ||
                other.researchResult == researchResult) &&
            (identical(other.designResult, designResult) ||
                other.designResult == designResult) &&
            const DeepCollectionEquality().equals(
              other._assetResult,
              _assetResult,
            ) &&
            (identical(other.engineResult, engineResult) ||
                other.engineResult == engineResult) &&
            const DeepCollectionEquality().equals(other._logs, _logs) &&
            const DeepCollectionEquality().equals(other._warnings, _warnings) &&
            (identical(other.totalDuration, totalDuration) ||
                other.totalDuration == totalDuration));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    workflowId,
    success,
    researchResult,
    designResult,
    const DeepCollectionEquality().hash(_assetResult),
    engineResult,
    const DeepCollectionEquality().hash(_logs),
    const DeepCollectionEquality().hash(_warnings),
    totalDuration,
  );

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrchestrationResultImplCopyWith<_$OrchestrationResultImpl> get copyWith =>
      __$$OrchestrationResultImplCopyWithImpl<_$OrchestrationResultImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$OrchestrationResultImplToJson(this);
  }
}

abstract class _OrchestrationResult implements OrchestrationResult {
  const factory _OrchestrationResult({
    required final String workflowId,
    required final bool success,
    required final ResearchResult? researchResult,
    required final GameDesignDocument? designResult,
    required final List<GeneratedAsset>? assetResult,
    required final EngineBuildResult? engineResult,
    required final List<String> logs,
    required final List<String> warnings,
    required final Duration totalDuration,
  }) = _$OrchestrationResultImpl;

  factory _OrchestrationResult.fromJson(Map<String, dynamic> json) =
      _$OrchestrationResultImpl.fromJson;

  @override
  String get workflowId;
  @override
  bool get success;
  @override
  ResearchResult? get researchResult;
  @override
  GameDesignDocument? get designResult;
  @override
  List<GeneratedAsset>? get assetResult;
  @override
  EngineBuildResult? get engineResult;
  @override
  List<String> get logs;
  @override
  List<String> get warnings;
  @override
  Duration get totalDuration;

  /// Create a copy of OrchestrationResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrchestrationResultImplCopyWith<_$OrchestrationResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
